/**
 * @license React
 * react-dom-server.edge.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import * as React from 'react';
import { Children } from 'react';
import * as ReactDOM from 'react-dom';

var ReactVersion = '18.3.0-canary-f71007574-20230817';

function scheduleWork(callback) {
	setTimeout(callback, 0);
}
const VIEW_SIZE = 512;
let currentView = null;
let writtenBytes = 0;
function beginWriting(destination) {
	currentView = new Uint8Array(VIEW_SIZE);
	writtenBytes = 0;
}
function writeChunk(destination, chunk) {
	if (chunk.byteLength === 0) {
		return;
	}

	if (chunk.byteLength > VIEW_SIZE) {
		// one that is cached by the streaming renderer. We will enqueu
		// it directly and expect it is not re-used

		if (writtenBytes > 0) {
			destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
			currentView = new Uint8Array(VIEW_SIZE);
			writtenBytes = 0;
		}

		destination.enqueue(chunk);
		return;
	}

	let bytesToWrite = chunk;
	const allowableBytes = currentView.length - writtenBytes;

	if (allowableBytes < bytesToWrite.byteLength) {
		// this chunk would overflow the current view. We enqueue a full view
		// and start a new view with the remaining chunk
		if (allowableBytes === 0) {
			// the current view is already full, send it
			destination.enqueue(currentView);
		} else {
			// fill up the current view and apply the remaining chunk bytes
			// to a new view.
			currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes); // writtenBytes += allowableBytes; // this can be skipped because we are going to immediately reset the view

			destination.enqueue(currentView);
			bytesToWrite = bytesToWrite.subarray(allowableBytes);
		}

		currentView = new Uint8Array(VIEW_SIZE);
		writtenBytes = 0;
	}

	currentView.set(bytesToWrite, writtenBytes);
	writtenBytes += bytesToWrite.byteLength;
}
function writeChunkAndReturn(destination, chunk) {
	writeChunk(destination, chunk); // in web streams there is no backpressure so we can alwas write more

	return true;
}
function completeWriting(destination) {
	if (currentView && writtenBytes > 0) {
		destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
		currentView = null;
		writtenBytes = 0;
	}
}
function close(destination) {
	destination.close();
}
const textEncoder = new TextEncoder();
function stringToChunk(content) {
	return textEncoder.encode(content);
}
function stringToPrecomputedChunk(content) {
	const precomputedChunk = textEncoder.encode(content);

	return precomputedChunk;
}
function clonePrecomputedChunk(precomputedChunk) {
	return precomputedChunk.byteLength > VIEW_SIZE
		? precomputedChunk.slice()
		: precomputedChunk;
}
function closeWithError(destination, error) {
	// $FlowFixMe[method-unbinding]
	if (typeof destination.error === 'function') {
		// $FlowFixMe[incompatible-call]: This is an Error object or the destination accepts other types.
		destination.error(error);
	} else {
		// Earlier implementations doesn't support this method. In that environment you're
		// supposed to throw from a promise returned but we don't return a promise in our
		// approach. We could fork this implementation but this is environment is an edge
		// case to begin with. It's even less common to run this in an older environment.
		// Even then, this is not where errors are supposed to happen and they get reported
		// to a global callback in addition to this anyway. So it's fine just to close this.
		destination.close();
	}
}

const assign = Object.assign;

// -----------------------------------------------------------------------------
const enableFloat = true; // Enables unstable_useMemoCache hook, intended as a compilation target for

// $FlowFixMe[method-unbinding]
const hasOwnProperty = Object.prototype.hasOwnProperty;

/* eslint-disable max-len */

const ATTRIBUTE_NAME_START_CHAR =
	':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
/* eslint-enable max-len */

const ATTRIBUTE_NAME_CHAR =
	ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
const VALID_ATTRIBUTE_NAME_REGEX = new RegExp(
	'^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$',
);
const illegalAttributeNameCache = {};
const validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
	if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
		return true;
	}

	if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
		return false;
	}

	if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
		validatedAttributeNameCache[attributeName] = true;
		return true;
	}

	illegalAttributeNameCache[attributeName] = true;

	return false;
}

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
const unitlessNumbers = new Set([
	'animationIterationCount',
	'aspectRatio',
	'borderImageOutset',
	'borderImageSlice',
	'borderImageWidth',
	'boxFlex',
	'boxFlexGroup',
	'boxOrdinalGroup',
	'columnCount',
	'columns',
	'flex',
	'flexGrow',
	'flexPositive',
	'flexShrink',
	'flexNegative',
	'flexOrder',
	'gridArea',
	'gridRow',
	'gridRowEnd',
	'gridRowSpan',
	'gridRowStart',
	'gridColumn',
	'gridColumnEnd',
	'gridColumnSpan',
	'gridColumnStart',
	'fontWeight',
	'lineClamp',
	'lineHeight',
	'opacity',
	'order',
	'orphans',
	'scale',
	'tabSize',
	'widows',
	'zIndex',
	'zoom',
	'fillOpacity', // SVG-related properties
	'floodOpacity',
	'stopOpacity',
	'strokeDasharray',
	'strokeDashoffset',
	'strokeMiterlimit',
	'strokeOpacity',
	'strokeWidth',
	'MozAnimationIterationCount', // Known Prefixed Properties
	'MozBoxFlex', // TODO: Remove these since they shouldn't be used in modern code
	'MozBoxFlexGroup',
	'MozLineClamp',
	'msAnimationIterationCount',
	'msFlex',
	'msZoom',
	'msFlexGrow',
	'msFlexNegative',
	'msFlexOrder',
	'msFlexPositive',
	'msFlexShrink',
	'msGridColumn',
	'msGridColumnSpan',
	'msGridRow',
	'msGridRowSpan',
	'WebkitAnimationIterationCount',
	'WebkitBoxFlex',
	'WebKitBoxFlexGroup',
	'WebkitBoxOrdinalGroup',
	'WebkitColumnCount',
	'WebkitColumns',
	'WebkitFlex',
	'WebkitFlexGrow',
	'WebkitFlexPositive',
	'WebkitFlexShrink',
	'WebkitLineClamp',
]);
function isUnitlessNumber(name) {
	return unitlessNumbers.has(name);
}

const aliases = new Map([
	['acceptCharset', 'accept-charset'],
	['htmlFor', 'for'],
	['httpEquiv', 'http-equiv'], // HTML and SVG attributes, but the SVG attribute is case sensitive.],
	['crossOrigin', 'crossorigin'], // This is a list of all SVG attributes that need special casing.
	// Regular attributes that just accept strings.],
	['accentHeight', 'accent-height'],
	['alignmentBaseline', 'alignment-baseline'],
	['arabicForm', 'arabic-form'],
	['baselineShift', 'baseline-shift'],
	['capHeight', 'cap-height'],
	['clipPath', 'clip-path'],
	['clipRule', 'clip-rule'],
	['colorInterpolation', 'color-interpolation'],
	['colorInterpolationFilters', 'color-interpolation-filters'],
	['colorProfile', 'color-profile'],
	['colorRendering', 'color-rendering'],
	['dominantBaseline', 'dominant-baseline'],
	['enableBackground', 'enable-background'],
	['fillOpacity', 'fill-opacity'],
	['fillRule', 'fill-rule'],
	['floodColor', 'flood-color'],
	['floodOpacity', 'flood-opacity'],
	['fontFamily', 'font-family'],
	['fontSize', 'font-size'],
	['fontSizeAdjust', 'font-size-adjust'],
	['fontStretch', 'font-stretch'],
	['fontStyle', 'font-style'],
	['fontVariant', 'font-variant'],
	['fontWeight', 'font-weight'],
	['glyphName', 'glyph-name'],
	['glyphOrientationHorizontal', 'glyph-orientation-horizontal'],
	['glyphOrientationVertical', 'glyph-orientation-vertical'],
	['horizAdvX', 'horiz-adv-x'],
	['horizOriginX', 'horiz-origin-x'],
	['imageRendering', 'image-rendering'],
	['letterSpacing', 'letter-spacing'],
	['lightingColor', 'lighting-color'],
	['markerEnd', 'marker-end'],
	['markerMid', 'marker-mid'],
	['markerStart', 'marker-start'],
	['overlinePosition', 'overline-position'],
	['overlineThickness', 'overline-thickness'],
	['paintOrder', 'paint-order'],
	['panose-1', 'panose-1'],
	['pointerEvents', 'pointer-events'],
	['renderingIntent', 'rendering-intent'],
	['shapeRendering', 'shape-rendering'],
	['stopColor', 'stop-color'],
	['stopOpacity', 'stop-opacity'],
	['strikethroughPosition', 'strikethrough-position'],
	['strikethroughThickness', 'strikethrough-thickness'],
	['strokeDasharray', 'stroke-dasharray'],
	['strokeDashoffset', 'stroke-dashoffset'],
	['strokeLinecap', 'stroke-linecap'],
	['strokeLinejoin', 'stroke-linejoin'],
	['strokeMiterlimit', 'stroke-miterlimit'],
	['strokeOpacity', 'stroke-opacity'],
	['strokeWidth', 'stroke-width'],
	['textAnchor', 'text-anchor'],
	['textDecoration', 'text-decoration'],
	['textRendering', 'text-rendering'],
	['transformOrigin', 'transform-origin'],
	['underlinePosition', 'underline-position'],
	['underlineThickness', 'underline-thickness'],
	['unicodeBidi', 'unicode-bidi'],
	['unicodeRange', 'unicode-range'],
	['unitsPerEm', 'units-per-em'],
	['vAlphabetic', 'v-alphabetic'],
	['vHanging', 'v-hanging'],
	['vIdeographic', 'v-ideographic'],
	['vMathematical', 'v-mathematical'],
	['vectorEffect', 'vector-effect'],
	['vertAdvY', 'vert-adv-y'],
	['vertOriginX', 'vert-origin-x'],
	['vertOriginY', 'vert-origin-y'],
	['wordSpacing', 'word-spacing'],
	['writingMode', 'writing-mode'],
	['xmlnsXlink', 'xmlns:xlink'],
	['xHeight', 'x-height'],
]);
function getAttributeAlias(name) {
	return aliases.get(name) || name;
}

// code copied and modified from escape-html
const matchHtmlRegExp = /["'&<>]/;
/**
 * Escapes special characters and HTML entities in a given html string.
 *
 * @param  {string} string HTML string to escape for later insertion
 * @return {string}
 * @public
 */

function escapeHtml(string) {
	const str = '' + string;
	const match = matchHtmlRegExp.exec(str);

	if (!match) {
		return str;
	}

	let escape;
	let html = '';
	let index;
	let lastIndex = 0;

	for (index = match.index; index < str.length; index++) {
		switch (str.charCodeAt(index)) {
			case 34:
				// "
				escape = '&quot;';
				break;

			case 38:
				// &
				escape = '&amp;';
				break;

			case 39:
				// '
				escape = '&#x27;'; // modified from escape-html; used to be '&#39'

				break;

			case 60:
				// <
				escape = '&lt;';
				break;

			case 62:
				// >
				escape = '&gt;';
				break;

			default:
				continue;
		}

		if (lastIndex !== index) {
			html += str.slice(lastIndex, index);
		}

		lastIndex = index + 1;
		html += escape;
	}

	return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
} // end code copied and modified from escape-html

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */

function escapeTextForBrowser(text) {
	if (typeof text === 'boolean' || typeof text === 'number') {
		// this shortcircuit helps perf for types that we know will never have
		// special characters, especially given that this function is used often
		// for numeric dom ids.
		return '' + text;
	}

	return escapeHtml(text);
}

const uppercasePattern = /([A-Z])/g;
const msPattern = /^ms-/;
/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */

function hyphenateStyleName(name) {
	return name
		.replace(uppercasePattern, '-$1')
		.toLowerCase()
		.replace(msPattern, '-ms-');
}

function sanitizeURL(url) {
	return url;
}

const isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

function isArray(a) {
	return isArrayImpl(a);
}

// The build script is at scripts/rollup/generate-inline-fizz-runtime.js.
// Run `yarn generate-inline-fizz-runtime` to generate.
const clientRenderBoundary =
	'$RX=function(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};';
const completeBoundary =
	'$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};';
const completeBoundaryWithStyles =
	'$RM=new Map;\n$RR=function(r,t,w){for(var u=$RC,n=$RM,p=new Map,q=document,g,b,h=q.querySelectorAll("link[data-precedence],style[data-precedence]"),v=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?v.push(b):("LINK"===b.tagName&&n.set(b.getAttribute("href"),b),p.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var f=w[b++];if(!f){k=!1;b=0;continue}var c=!1,m=0;var d=f[m++];if(a=n.get(d)){var e=a._p;c=!0}else{a=q.createElement("link");a.href=d;a.rel="stylesheet";for(a.dataset.precedence=\nl=f[m++];e=f[m++];)a.setAttribute(e,f[m++]);e=a._p=new Promise(function(x,y){a.onload=x;a.onerror=y});n.set(d,a)}d=a.getAttribute("media");!e||"l"===e.s||d&&!matchMedia(d).matches||h.push(e);if(c)continue}else{a=v[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=p.get(l)||g;c===g&&(g=a);p.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=q.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(u.bind(null,r,t,""),u.bind(null,r,t,"Resource failed to load"))};';
const completeSegment =
	'$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};';
const formReplaying =
	'addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error(\'A React form was unexpectedly submitted.\')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.getRootNode(),(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,\nd,b))}});';

const ReactSharedInternals =
	React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

const ReactDOMSharedInternals =
	ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

const ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;
const ReactDOMServerDispatcher = {
	prefetchDNS,
	preconnect,
	preload,
	preinit,
};
function prepareHostDispatcher() {
	ReactDOMCurrentDispatcher.current = ReactDOMServerDispatcher;
} // Used to distinguish these contexts from ones used in other renderers.
const ScriptStreamingFormat = 0;
const DataStreamingFormat = 1;
const NothingSent =
	/*                      */
	0b00000;
const SentCompleteSegmentFunction =
	/*      */
	0b00001;
const SentCompleteBoundaryFunction =
	/*     */
	0b00010;
const SentClientRenderFunction =
	/*         */
	0b00100;
const SentStyleInsertionFunction =
	/*       */
	0b01000;

const dataElementQuotedEnd = stringToPrecomputedChunk('"></template>');
const startInlineScript = stringToPrecomputedChunk('<script>');
const endInlineScript = stringToPrecomputedChunk('</script>');
const startScriptSrc = stringToPrecomputedChunk('<script src="');
const startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
const scriptNonce = stringToPrecomputedChunk('" nonce="');
const scriptIntegirty = stringToPrecomputedChunk('" integrity="');
const scriptCrossOrigin = stringToPrecomputedChunk('" crossorigin="');
const endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
/**
 * This escaping function is designed to work with bootstrapScriptContent only.
 * because we know we are escaping the entire script. We can avoid for instance
 * escaping html comment string sequences that are valid javascript as well because
 * if there are no sebsequent <script sequences the html parser will never enter
 * script data double escaped state (see: https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state)
 *
 * While untrusted script content should be made safe before using this api it will
 * ensure that the script cannot be early terminated or never terminated state
 */

function escapeBootstrapScriptContent(scriptText) {
	return ('' + scriptText).replace(scriptRegex, scriptReplacer);
}

const scriptRegex = /(<\/|<)(s)(cript)/gi;

const scriptReplacer = (match, prefix, s, suffix) =>
	'' + prefix + (s === 's' ? '\\u0073' : '\\u0053') + suffix; // Allows us to keep track of what we've already written so we can refer back to it.
// if passed externalRuntimeConfig and the enableFizzExternalRuntime feature flag
// is set, the server will send instructions via data attributes (instead of inline scripts)

function createResponseState(
	resources,
	identifierPrefix,
	nonce,
	bootstrapScriptContent,
	bootstrapScripts,
	bootstrapModules,
	externalRuntimeConfig,
) {
	const idPrefix = identifierPrefix === undefined ? '' : identifierPrefix;
	const inlineScriptWithNonce =
		nonce === undefined
			? startInlineScript
			: stringToPrecomputedChunk(
					'<script nonce="' + escapeTextForBrowser(nonce) + '">',
				);
	const bootstrapChunks = [];
	let externalRuntimeScript = null;
	let streamingFormat = ScriptStreamingFormat;

	if (bootstrapScriptContent !== undefined) {
		bootstrapChunks.push(
			inlineScriptWithNonce,
			stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)),
			endInlineScript,
		);
	}

	{
		if (externalRuntimeConfig !== undefined) {
			streamingFormat = DataStreamingFormat;

			if (typeof externalRuntimeConfig === 'string') {
				externalRuntimeScript = {
					src: externalRuntimeConfig,
					chunks: [],
				};
				pushScriptImpl(externalRuntimeScript.chunks, {
					src: externalRuntimeConfig,
					async: true,
					integrity: undefined,
					nonce: nonce,
				});
			} else {
				externalRuntimeScript = {
					src: externalRuntimeConfig.src,
					chunks: [],
				};
				pushScriptImpl(externalRuntimeScript.chunks, {
					src: externalRuntimeConfig.src,
					async: true,
					integrity: externalRuntimeConfig.integrity,
					nonce: nonce,
				});
			}
		}
	}

	if (bootstrapScripts !== undefined) {
		for (let i = 0; i < bootstrapScripts.length; i++) {
			const scriptConfig = bootstrapScripts[i];
			const src =
				typeof scriptConfig === 'string' ? scriptConfig : scriptConfig.src;
			const integrity =
				typeof scriptConfig === 'string' ? undefined : scriptConfig.integrity;
			const crossOrigin =
				typeof scriptConfig === 'string' || scriptConfig.crossOrigin == null
					? undefined
					: scriptConfig.crossOrigin === 'use-credentials'
						? 'use-credentials'
						: '';
			preloadBootstrapScript(resources, src, nonce, integrity, crossOrigin);
			bootstrapChunks.push(
				startScriptSrc,
				stringToChunk(escapeTextForBrowser(src)),
			);

			if (nonce) {
				bootstrapChunks.push(
					scriptNonce,
					stringToChunk(escapeTextForBrowser(nonce)),
				);
			}

			if (integrity) {
				bootstrapChunks.push(
					scriptIntegirty,
					stringToChunk(escapeTextForBrowser(integrity)),
				);
			}

			if (typeof crossOrigin === 'string') {
				bootstrapChunks.push(
					scriptCrossOrigin,
					stringToChunk(escapeTextForBrowser(crossOrigin)),
				);
			}

			bootstrapChunks.push(endAsyncScript);
		}
	}

	if (bootstrapModules !== undefined) {
		for (let i = 0; i < bootstrapModules.length; i++) {
			const scriptConfig = bootstrapModules[i];
			const src =
				typeof scriptConfig === 'string' ? scriptConfig : scriptConfig.src;
			const integrity =
				typeof scriptConfig === 'string' ? undefined : scriptConfig.integrity;
			const crossOrigin =
				typeof scriptConfig === 'string' || scriptConfig.crossOrigin == null
					? undefined
					: scriptConfig.crossOrigin === 'use-credentials'
						? 'use-credentials'
						: '';
			preloadBootstrapModule(resources, src, nonce, integrity, crossOrigin);
			bootstrapChunks.push(
				startModuleSrc,
				stringToChunk(escapeTextForBrowser(src)),
			);

			if (nonce) {
				bootstrapChunks.push(
					scriptNonce,
					stringToChunk(escapeTextForBrowser(nonce)),
				);
			}

			if (integrity) {
				bootstrapChunks.push(
					scriptIntegirty,
					stringToChunk(escapeTextForBrowser(integrity)),
				);
			}

			if (typeof crossOrigin === 'string') {
				bootstrapChunks.push(
					scriptCrossOrigin,
					stringToChunk(escapeTextForBrowser(crossOrigin)),
				);
			}

			bootstrapChunks.push(endAsyncScript);
		}
	}

	return {
		bootstrapChunks: bootstrapChunks,
		placeholderPrefix: stringToPrecomputedChunk(idPrefix + 'P:'),
		segmentPrefix: stringToPrecomputedChunk(idPrefix + 'S:'),
		boundaryPrefix: idPrefix + 'B:',
		idPrefix: idPrefix,
		nextSuspenseID: 0,
		streamingFormat,
		startInlineScript: inlineScriptWithNonce,
		instructions: NothingSent,
		externalRuntimeScript,
		htmlChunks: null,
		headChunks: null,
		hasBody: false,
		charsetChunks: [],
		preconnectChunks: [],
		preloadChunks: [],
		hoistableChunks: [],
		stylesToHoist: false,
		nonce,
	};
} // Constants for the insertion mode we're currently writing in. We don't encode all HTML5 insertion
// modes. We only include the variants as they matter for the sake of our purposes.
// We don't actually provide the namespace therefore we use constants instead of the string.

const ROOT_HTML_MODE = 0; // Used for the root most element tag.
// We have a less than HTML_HTML_MODE check elsewhere. If you add more cases here, make sure it
// still makes sense

const HTML_HTML_MODE = 1; // Used for the <html> if it is at the top level.

const HTML_MODE = 2;
const SVG_MODE = 3;
const MATHML_MODE = 4;
const HTML_TABLE_MODE = 5;
const HTML_TABLE_BODY_MODE = 6;
const HTML_TABLE_ROW_MODE = 7;
const HTML_COLGROUP_MODE = 8; // We have a greater than HTML_TABLE_MODE check elsewhere. If you add more cases here, make sure it
// still makes sense
// Lets us keep track of contextual state and pick it back up after suspending.

function createFormatContext(insertionMode, selectedValue, noscriptTagInScope) {
	return {
		insertionMode,
		selectedValue,
		noscriptTagInScope,
	};
}

function createRootFormatContext(namespaceURI) {
	const insertionMode =
		namespaceURI === 'http://www.w3.org/2000/svg'
			? SVG_MODE
			: namespaceURI === 'http://www.w3.org/1998/Math/MathML'
				? MATHML_MODE
				: ROOT_HTML_MODE;
	return createFormatContext(insertionMode, null, false);
}
function getChildFormatContext(parentContext, type, props) {
	switch (type) {
		case 'noscript':
			return createFormatContext(HTML_MODE, null, true);

		case 'select':
			return createFormatContext(
				HTML_MODE,
				props.value != null ? props.value : props.defaultValue,
				parentContext.noscriptTagInScope,
			);

		case 'svg':
			return createFormatContext(
				SVG_MODE,
				null,
				parentContext.noscriptTagInScope,
			);

		case 'math':
			return createFormatContext(
				MATHML_MODE,
				null,
				parentContext.noscriptTagInScope,
			);

		case 'foreignObject':
			return createFormatContext(
				HTML_MODE,
				null,
				parentContext.noscriptTagInScope,
			);
		// Table parents are special in that their children can only be created at all if they're
		// wrapped in a table parent. So we need to encode that we're entering this mode.

		case 'table':
			return createFormatContext(
				HTML_TABLE_MODE,
				null,
				parentContext.noscriptTagInScope,
			);

		case 'thead':
		case 'tbody':
		case 'tfoot':
			return createFormatContext(
				HTML_TABLE_BODY_MODE,
				null,
				parentContext.noscriptTagInScope,
			);

		case 'colgroup':
			return createFormatContext(
				HTML_COLGROUP_MODE,
				null,
				parentContext.noscriptTagInScope,
			);

		case 'tr':
			return createFormatContext(
				HTML_TABLE_ROW_MODE,
				null,
				parentContext.noscriptTagInScope,
			);
	}

	if (parentContext.insertionMode >= HTML_TABLE_MODE) {
		// Whatever tag this was, it wasn't a table parent or other special parent, so we must have
		// entered plain HTML again.
		return createFormatContext(
			HTML_MODE,
			null,
			parentContext.noscriptTagInScope,
		);
	}

	if (parentContext.insertionMode === ROOT_HTML_MODE) {
		if (type === 'html') {
			// We've emitted the root and is now in <html> mode.
			return createFormatContext(HTML_HTML_MODE, null, false);
		} else {
			// We've emitted the root and is now in plain HTML mode.
			return createFormatContext(HTML_MODE, null, false);
		}
	} else if (parentContext.insertionMode === HTML_HTML_MODE) {
		// We've emitted the document element and is now in plain HTML mode.
		return createFormatContext(HTML_MODE, null, false);
	}

	return parentContext;
}
const UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
function assignSuspenseBoundaryID(responseState) {
	const generatedID = responseState.nextSuspenseID++;
	return stringToPrecomputedChunk(
		responseState.boundaryPrefix + generatedID.toString(16),
	);
}
function makeId(responseState, treeId, localId) {
	const idPrefix = responseState.idPrefix;
	let id = ':' + idPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end
	// that represents the position of this useId hook among all the useId
	// hooks for this fiber.

	if (localId > 0) {
		id += 'H' + localId.toString(32);
	}

	return id + ':';
}

function encodeHTMLTextNode(text) {
	return escapeTextForBrowser(text);
}

const textSeparator = stringToPrecomputedChunk('<!-- -->');
function pushTextInstance(target, text, responseState, textEmbedded) {
	if (text === '') {
		// Empty text doesn't have a DOM node representation and the hydration is aware of this.
		return textEmbedded;
	}

	if (textEmbedded) {
		target.push(textSeparator);
	}

	target.push(stringToChunk(encodeHTMLTextNode(text)));
	return true;
} // Called when Fizz is done with a Segment. Currently the only purpose is to conditionally
// emit a text separator when we don't know for sure it is safe to omit

function pushSegmentFinale(
	target,
	responseState,
	lastPushedText,
	textEmbedded,
) {
	if (lastPushedText && textEmbedded) {
		target.push(textSeparator);
	}
}
const styleNameCache = new Map();

function processStyleName(styleName) {
	const chunk = styleNameCache.get(styleName);

	if (chunk !== undefined) {
		return chunk;
	}

	const result = stringToPrecomputedChunk(
		escapeTextForBrowser(hyphenateStyleName(styleName)),
	);
	styleNameCache.set(styleName, result);
	return result;
}

const styleAttributeStart = stringToPrecomputedChunk(' style="');
const styleAssign = stringToPrecomputedChunk(':');
const styleSeparator = stringToPrecomputedChunk(';');

function pushStyleAttribute(target, style) {
	if (typeof style !== 'object') {
		throw new Error(
			'The `style` prop expects a mapping from style properties to values, ' +
				"not a string. For example, style={{marginRight: spacing + 'em'}} when " +
				'using JSX.',
		);
	}

	let isFirst = true;

	for (const styleName in style) {
		if (!hasOwnProperty.call(style, styleName)) {
			continue;
		} // If you provide unsafe user data here they can inject arbitrary CSS
		// which may be problematic (I couldn't repro this):
		// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
		// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
		// This is not an XSS hole but instead a potential CSS injection issue
		// which has lead to a greater discussion about how we're going to
		// trust URLs moving forward. See #2115901

		const styleValue = style[styleName];

		if (
			styleValue == null ||
			typeof styleValue === 'boolean' ||
			styleValue === ''
		) {
			// TODO: We used to set empty string as a style with an empty value. Does that ever make sense?
			continue;
		}

		let nameChunk;
		let valueChunk;
		const isCustomProperty = styleName.indexOf('--') === 0;

		if (isCustomProperty) {
			nameChunk = stringToChunk(escapeTextForBrowser(styleName));

			valueChunk = stringToChunk(
				escapeTextForBrowser(('' + styleValue).trim()),
			);
		} else {
			nameChunk = processStyleName(styleName);

			if (typeof styleValue === 'number') {
				if (styleValue !== 0 && !isUnitlessNumber(styleName)) {
					valueChunk = stringToChunk(styleValue + 'px'); // Presumes implicit 'px' suffix for unitless numbers
				} else {
					valueChunk = stringToChunk('' + styleValue);
				}
			} else {
				valueChunk = stringToChunk(
					escapeTextForBrowser(('' + styleValue).trim()),
				);
			}
		}

		if (isFirst) {
			isFirst = false; // If it's first, we don't need any separators prefixed.

			target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
		} else {
			target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
		}
	}

	if (!isFirst) {
		target.push(attributeEnd);
	}
}

const attributeSeparator = stringToPrecomputedChunk(' ');
const attributeAssign = stringToPrecomputedChunk('="');
const attributeEnd = stringToPrecomputedChunk('"');
const attributeEmptyString = stringToPrecomputedChunk('=""');

function pushBooleanAttribute(target, name, value) {
	// not null or undefined
	if (value && typeof value !== 'function' && typeof value !== 'symbol') {
		target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);
	}
}

function pushStringAttribute(target, name, value) {
	// not null or undefined
	if (
		typeof value !== 'function' &&
		typeof value !== 'symbol' &&
		typeof value !== 'boolean'
	) {
		target.push(
			attributeSeparator,
			stringToChunk(name),
			attributeAssign,
			stringToChunk(escapeTextForBrowser(value)),
			attributeEnd,
		);
	}
}
// than on the client and hopefully it's googleable.

stringToPrecomputedChunk(
	escapeTextForBrowser(
		// eslint-disable-next-line no-script-url
		"javascript:throw new Error('A React form was unexpectedly submitted.')",
	),
);
const startHiddenInputChunk = stringToPrecomputedChunk('<input type="hidden"');

function pushAdditionalFormField(value, key) {
	const target = this;
	target.push(startHiddenInputChunk);

	if (typeof value !== 'string') {
		throw new Error(
			'File/Blob fields are not yet supported in progressive forms. ' +
				'It probably means you are closing over binary data or FormData in a Server Action.',
		);
	}

	pushStringAttribute(target, 'name', key);
	pushStringAttribute(target, 'value', value);
	target.push(endOfStartTagSelfClosing);
}

function pushAdditionalFormFields(target, formData) {
	if (formData !== null) {
		// $FlowFixMe[prop-missing]: FormData has forEach.
		formData.forEach(pushAdditionalFormField, target);
	}
}

function pushFormActionAttribute(
	target,
	responseState,
	formAction,
	formEncType,
	formMethod,
	formTarget,
	name,
) {
	let formData = null;

	if (name != null) {
		pushAttribute(target, 'name', name);
	}

	if (formAction != null) {
		pushAttribute(target, 'formAction', formAction);
	}

	if (formEncType != null) {
		pushAttribute(target, 'formEncType', formEncType);
	}

	if (formMethod != null) {
		pushAttribute(target, 'formMethod', formMethod);
	}

	if (formTarget != null) {
		pushAttribute(target, 'formTarget', formTarget);
	}

	return formData;
}

function pushAttribute(target, name, value) {
	// not null or undefined
	switch (name) {
		// These are very common props and therefore are in the beginning of the switch.
		// TODO: aria-label is a very common prop but allows booleans so is not like the others
		// but should ideally go in this list too.
		case 'className': {
			pushStringAttribute(target, 'class', value);
			break;
		}

		case 'tabIndex': {
			pushStringAttribute(target, 'tabindex', value);
			break;
		}

		case 'dir':
		case 'role':
		case 'viewBox':
		case 'width':
		case 'height': {
			pushStringAttribute(target, name, value);
			break;
		}

		case 'style': {
			pushStyleAttribute(target, value);
			return;
		}

		case 'src':
		case 'href':
		// Fall through to the last case which shouldn't remove empty strings.

		case 'action':
		case 'formAction': {
			// TODO: Consider only special casing these for each tag.
			if (
				value == null ||
				typeof value === 'function' ||
				typeof value === 'symbol' ||
				typeof value === 'boolean'
			) {
				return;
			}

			const sanitizedValue = sanitizeURL('' + value);
			target.push(
				attributeSeparator,
				stringToChunk(name),
				attributeAssign,
				stringToChunk(escapeTextForBrowser(sanitizedValue)),
				attributeEnd,
			);
			return;
		}

		case 'defaultValue':
		case 'defaultChecked': // These shouldn't be set as attributes on generic HTML elements.

		case 'innerHTML': // Must use dangerouslySetInnerHTML instead.

		case 'suppressContentEditableWarning':
		case 'suppressHydrationWarning':
			// Ignored. These are built-in to React on the client.
			return;

		case 'autoFocus':
		case 'multiple':
		case 'muted': {
			pushBooleanAttribute(target, name.toLowerCase(), value);
			return;
		}

		case 'xlinkHref': {
			if (
				typeof value === 'function' ||
				typeof value === 'symbol' ||
				typeof value === 'boolean'
			) {
				return;
			}

			const sanitizedValue = sanitizeURL('' + value);
			target.push(
				attributeSeparator,
				stringToChunk('xlink:href'),
				attributeAssign,
				stringToChunk(escapeTextForBrowser(sanitizedValue)),
				attributeEnd,
			);
			return;
		}

		case 'contentEditable':
		case 'spellCheck':
		case 'draggable':
		case 'value':
		case 'autoReverse':
		case 'externalResourcesRequired':
		case 'focusable':
		case 'preserveAlpha': {
			// Booleanish String
			// These are "enumerated" attributes that accept "true" and "false".
			// In React, we let users pass `true` and `false` even though technically
			// these aren't boolean attributes (they are coerced to strings).
			if (typeof value !== 'function' && typeof value !== 'symbol') {
				target.push(
					attributeSeparator,
					stringToChunk(name),
					attributeAssign,
					stringToChunk(escapeTextForBrowser(value)),
					attributeEnd,
				);
			}

			return;
		}

		case 'allowFullScreen':
		case 'async':
		case 'autoPlay':
		case 'controls':
		case 'default':
		case 'defer':
		case 'disabled':
		case 'disablePictureInPicture':
		case 'disableRemotePlayback':
		case 'formNoValidate':
		case 'hidden':
		case 'loop':
		case 'noModule':
		case 'noValidate':
		case 'open':
		case 'playsInline':
		case 'readOnly':
		case 'required':
		case 'reversed':
		case 'scoped':
		case 'seamless':
		case 'itemScope': {
			// Boolean
			if (value && typeof value !== 'function' && typeof value !== 'symbol') {
				target.push(
					attributeSeparator,
					stringToChunk(name),
					attributeEmptyString,
				);
			}

			return;
		}

		case 'capture':
		case 'download': {
			// Overloaded Boolean
			if (value === true) {
				target.push(
					attributeSeparator,
					stringToChunk(name),
					attributeEmptyString,
				);
			} else if (value === false);
			else if (typeof value !== 'function' && typeof value !== 'symbol') {
				target.push(
					attributeSeparator,
					stringToChunk(name),
					attributeAssign,
					stringToChunk(escapeTextForBrowser(value)),
					attributeEnd,
				);
			}

			return;
		}

		case 'cols':
		case 'rows':
		case 'size':
		case 'span': {
			// These are HTML attributes that must be positive numbers.
			if (
				typeof value !== 'function' &&
				typeof value !== 'symbol' &&
				!isNaN(value) &&
				value >= 1
			) {
				target.push(
					attributeSeparator,
					stringToChunk(name),
					attributeAssign,
					stringToChunk(escapeTextForBrowser(value)),
					attributeEnd,
				);
			}

			return;
		}

		case 'rowSpan':
		case 'start': {
			// These are HTML attributes that must be numbers.
			if (
				typeof value !== 'function' &&
				typeof value !== 'symbol' &&
				!isNaN(value)
			) {
				target.push(
					attributeSeparator,
					stringToChunk(name),
					attributeAssign,
					stringToChunk(escapeTextForBrowser(value)),
					attributeEnd,
				);
			}

			return;
		}

		case 'xlinkActuate':
			pushStringAttribute(target, 'xlink:actuate', value);
			return;

		case 'xlinkArcrole':
			pushStringAttribute(target, 'xlink:arcrole', value);
			return;

		case 'xlinkRole':
			pushStringAttribute(target, 'xlink:role', value);
			return;

		case 'xlinkShow':
			pushStringAttribute(target, 'xlink:show', value);
			return;

		case 'xlinkTitle':
			pushStringAttribute(target, 'xlink:title', value);
			return;

		case 'xlinkType':
			pushStringAttribute(target, 'xlink:type', value);
			return;

		case 'xmlBase':
			pushStringAttribute(target, 'xml:base', value);
			return;

		case 'xmlLang':
			pushStringAttribute(target, 'xml:lang', value);
			return;

		case 'xmlSpace':
			pushStringAttribute(target, 'xml:space', value);
			return;

		default:
			if (
				// shouldIgnoreAttribute
				// We have already filtered out null/undefined and reserved words.
				name.length > 2 &&
				(name[0] === 'o' || name[0] === 'O') &&
				(name[1] === 'n' || name[1] === 'N')
			) {
				return;
			}

			const attributeName = getAttributeAlias(name);

			if (isAttributeNameSafe(attributeName)) {
				// shouldRemoveAttribute
				switch (typeof value) {
					case 'function':
					case 'symbol':
						// eslint-disable-line
						return;

					case 'boolean': {
						const prefix = attributeName.toLowerCase().slice(0, 5);

						if (prefix !== 'data-' && prefix !== 'aria-') {
							return;
						}
					}
				}

				target.push(
					attributeSeparator,
					stringToChunk(attributeName),
					attributeAssign,
					stringToChunk(escapeTextForBrowser(value)),
					attributeEnd,
				);
			}
	}
}

const endOfStartTag = stringToPrecomputedChunk('>');
const endOfStartTagSelfClosing = stringToPrecomputedChunk('/>');

function pushInnerHTML(target, innerHTML, children) {
	if (innerHTML != null) {
		if (children != null) {
			throw new Error(
				'Can only set one of `children` or `props.dangerouslySetInnerHTML`.',
			);
		}

		if (typeof innerHTML !== 'object' || !('__html' in innerHTML)) {
			throw new Error(
				'`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' +
					'Please visit https://reactjs.org/link/dangerously-set-inner-html ' +
					'for more information.',
			);
		}

		const html = innerHTML.__html;

		if (html !== null && html !== undefined) {
			target.push(stringToChunk('' + html));
		}
	}
} // TODO: Move these to ResponseState so that we warn for every request.

function pushStartSelect(target, props) {
	target.push(startChunkForTag('select'));
	let children = null;
	let innerHTML = null;

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
					children = propValue;
					break;

				case 'dangerouslySetInnerHTML':
					// TODO: This doesn't really make sense for select since it can't use the controlled
					// value in the innerHTML.
					innerHTML = propValue;
					break;

				case 'defaultValue':
				case 'value':
					// These are set on the Context instead and applied to the nested options.
					break;

				default:
					pushAttribute(target, propKey, propValue);
					break;
			}
		}
	}

	target.push(endOfStartTag);
	pushInnerHTML(target, innerHTML, children);
	return children;
}

function flattenOptionChildren(children) {
	let content = ''; // Flatten children and warn if they aren't strings or numbers;
	// invalid types are ignored.

	Children.forEach(children, function (child) {
		if (child == null) {
			return;
		}

		content += child;
	});
	return content;
}

const selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');

function pushStartOption(target, props, formatContext) {
	const selectedValue = formatContext.selectedValue;
	target.push(startChunkForTag('option'));
	let children = null;
	let value = null;
	let selected = null;
	let innerHTML = null;

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
					children = propValue;
					break;

				case 'selected':
					// ignore
					selected = propValue;

					break;

				case 'dangerouslySetInnerHTML':
					innerHTML = propValue;
					break;

				case 'value':
					value = propValue;
				// We intentionally fallthrough to also set the attribute on the node.

				default:
					pushAttribute(target, propKey, propValue);
					break;
			}
		}
	}

	if (selectedValue != null) {
		let stringValue;

		if (value !== null) {
			stringValue = '' + value;
		} else {
			stringValue = flattenOptionChildren(children);
		}

		if (isArray(selectedValue)) {
			// multiple
			for (let i = 0; i < selectedValue.length; i++) {
				const v = '' + selectedValue[i];

				if (v === stringValue) {
					target.push(selectedMarkerAttribute);
					break;
				}
			}
		} else {
			if ('' + selectedValue === stringValue) {
				target.push(selectedMarkerAttribute);
			}
		}
	} else if (selected) {
		target.push(selectedMarkerAttribute);
	}

	target.push(endOfStartTag);
	pushInnerHTML(target, innerHTML, children);
	return children;
}

stringToPrecomputedChunk(formReplaying);

function pushStartForm(target, props, responseState) {
	target.push(startChunkForTag('form'));
	let children = null;
	let innerHTML = null;
	let formAction = null;
	let formEncType = null;
	let formMethod = null;
	let formTarget = null;

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
					children = propValue;
					break;

				case 'dangerouslySetInnerHTML':
					innerHTML = propValue;
					break;

				case 'action':
					formAction = propValue;
					break;

				case 'encType':
					formEncType = propValue;
					break;

				case 'method':
					formMethod = propValue;
					break;

				case 'target':
					formTarget = propValue;
					break;

				default:
					pushAttribute(target, propKey, propValue);
					break;
			}
		}
	}

	if (formAction != null) {
		pushAttribute(target, 'action', formAction);
	}

	if (formEncType != null) {
		pushAttribute(target, 'encType', formEncType);
	}

	if (formMethod != null) {
		pushAttribute(target, 'method', formMethod);
	}

	if (formTarget != null) {
		pushAttribute(target, 'target', formTarget);
	}

	target.push(endOfStartTag);

	pushInnerHTML(target, innerHTML, children);

	if (typeof children === 'string') {
		// Special case children as a string to avoid the unnecessary comment.
		// TODO: Remove this special case after the general optimization is in place.
		target.push(stringToChunk(encodeHTMLTextNode(children)));
		return null;
	}

	return children;
}

function pushInput(target, props, responseState) {
	target.push(startChunkForTag('input'));
	let name = null;
	let formAction = null;
	let formEncType = null;
	let formMethod = null;
	let formTarget = null;
	let value = null;
	let defaultValue = null;
	let checked = null;
	let defaultChecked = null;

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
				case 'dangerouslySetInnerHTML':
					throw new Error(
						'input' +
							' is a self-closing tag and must neither have `children` nor ' +
							'use `dangerouslySetInnerHTML`.',
					);

				case 'name':
					name = propValue;
					break;

				case 'formAction':
					formAction = propValue;
					break;

				case 'formEncType':
					formEncType = propValue;
					break;

				case 'formMethod':
					formMethod = propValue;
					break;

				case 'formTarget':
					formTarget = propValue;
					break;

				case 'defaultChecked':
					defaultChecked = propValue;
					break;

				case 'defaultValue':
					defaultValue = propValue;
					break;

				case 'checked':
					checked = propValue;
					break;

				case 'value':
					value = propValue;
					break;

				default:
					pushAttribute(target, propKey, propValue);
					break;
			}
		}
	}

	const formData = pushFormActionAttribute(
		target,
		responseState,
		formAction,
		formEncType,
		formMethod,
		formTarget,
		name,
	);

	if (checked !== null) {
		pushBooleanAttribute(target, 'checked', checked);
	} else if (defaultChecked !== null) {
		pushBooleanAttribute(target, 'checked', defaultChecked);
	}

	if (value !== null) {
		pushAttribute(target, 'value', value);
	} else if (defaultValue !== null) {
		pushAttribute(target, 'value', defaultValue);
	}

	target.push(endOfStartTagSelfClosing); // We place any additional hidden form fields after the input.

	pushAdditionalFormFields(target, formData);
	return null;
}

function pushStartButton(target, props, responseState) {
	target.push(startChunkForTag('button'));
	let children = null;
	let innerHTML = null;
	let name = null;
	let formAction = null;
	let formEncType = null;
	let formMethod = null;
	let formTarget = null;

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
					children = propValue;
					break;

				case 'dangerouslySetInnerHTML':
					innerHTML = propValue;
					break;

				case 'name':
					name = propValue;
					break;

				case 'formAction':
					formAction = propValue;
					break;

				case 'formEncType':
					formEncType = propValue;
					break;

				case 'formMethod':
					formMethod = propValue;
					break;

				case 'formTarget':
					formTarget = propValue;
					break;

				default:
					pushAttribute(target, propKey, propValue);
					break;
			}
		}
	}

	const formData = pushFormActionAttribute(
		target,
		responseState,
		formAction,
		formEncType,
		formMethod,
		formTarget,
		name,
	);
	target.push(endOfStartTag); // We place any additional hidden form fields we need to include inside the button itself.

	pushAdditionalFormFields(target, formData);
	pushInnerHTML(target, innerHTML, children);

	if (typeof children === 'string') {
		// Special case children as a string to avoid the unnecessary comment.
		// TODO: Remove this special case after the general optimization is in place.
		target.push(stringToChunk(encodeHTMLTextNode(children)));
		return null;
	}

	return children;
}

function pushStartTextArea(target, props) {
	target.push(startChunkForTag('textarea'));
	let value = null;
	let defaultValue = null;
	let children = null;

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
					children = propValue;
					break;

				case 'value':
					value = propValue;
					break;

				case 'defaultValue':
					defaultValue = propValue;
					break;

				case 'dangerouslySetInnerHTML':
					throw new Error(
						'`dangerouslySetInnerHTML` does not make sense on <textarea>.',
					);

				default:
					pushAttribute(target, propKey, propValue);
					break;
			}
		}
	}

	if (value === null && defaultValue !== null) {
		value = defaultValue;
	}

	target.push(endOfStartTag); // TODO (yungsters): Remove support for children content in <textarea>.

	if (children != null) {
		if (value != null) {
			throw new Error(
				'If you supply `defaultValue` on a <textarea>, do not pass children.',
			);
		}

		if (isArray(children)) {
			if (children.length > 1) {
				throw new Error('<textarea> can only have at most one child.');
			} // TODO: remove the coercion and the DEV check below because it will

			value = '' + children[0];
		}

		value = '' + children;
	}

	if (typeof value === 'string' && value[0] === '\n') {
		// text/html ignores the first character in these tags if it's a newline
		// Prefer to break application/xml over text/html (for now) by adding
		// a newline specifically to get eaten by the parser. (Alternately for
		// textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
		// \r is normalized out by HTMLTextAreaElement#value.)
		// See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
		// See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
		// See: <http://www.w3.org/TR/html5/syntax.html#newlines>
		// See: Parsing of "textarea" "listing" and "pre" elements
		//  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
		target.push(leadingNewline);
	} // ToString and push directly instead of recurse over children.
	// We don't really support complex children in the value anyway.
	// This also currently avoids a trailing comment node which breaks textarea.

	if (value !== null) {
		target.push(stringToChunk(encodeHTMLTextNode('' + value)));
	}

	return null;
}

function pushMeta(
	target,
	props,
	responseState,
	textEmbedded,
	insertionMode,
	noscriptTagInScope,
) {
	{
		if (
			insertionMode === SVG_MODE ||
			noscriptTagInScope ||
			props.itemProp != null
		) {
			return pushSelfClosing(target, props, 'meta');
		} else {
			if (textEmbedded) {
				// This link follows text but we aren't writing a tag. while not as efficient as possible we need
				// to be safe and assume text will follow by inserting a textSeparator
				target.push(textSeparator);
			}

			if (typeof props.charSet === 'string') {
				return pushSelfClosing(responseState.charsetChunks, props, 'meta');
			} else {
				return pushSelfClosing(responseState.hoistableChunks, props, 'meta');
			}
		}
	}
}

function pushLink(
	target,
	props,
	responseState,
	resources,
	textEmbedded,
	insertionMode,
	noscriptTagInScope,
) {
	{
		const rel = props.rel;
		const href = props.href;
		const precedence = props.precedence;

		if (
			insertionMode === SVG_MODE ||
			noscriptTagInScope ||
			props.itemProp != null ||
			typeof rel !== 'string' ||
			typeof href !== 'string' ||
			href === ''
		) {
			pushLinkImpl(target, props);
			return null;
		}

		if (props.rel === 'stylesheet') {
			// This <link> may hoistable as a Stylesheet Resource, otherwise it will emit in place
			const key = getResourceKey('style', href);

			if (
				typeof precedence !== 'string' ||
				props.disabled != null ||
				props.onLoad ||
				props.onError
			) {
				return pushLinkImpl(target, props);
			} else {
				// This stylesheet refers to a Resource and we create a new one if necessary
				let resource = resources.stylesMap.get(key);

				if (!resource) {
					const resourceProps = stylesheetPropsFromRawProps(props);
					const preloadResource = resources.preloadsMap.get(key);
					let state = NoState;

					if (preloadResource) {
						// If we already had a preload we don't want that resource to flush directly.
						// We let the newly created resource govern flushing.
						preloadResource.state |= Blocked;
						adoptPreloadPropsForStylesheetProps(
							resourceProps,
							preloadResource.props,
						);

						if (preloadResource.state & Flushed) {
							state = PreloadFlushed;
						}
					}

					resource = {
						type: 'stylesheet',
						chunks: [],
						state,
						props: resourceProps,
					};
					resources.stylesMap.set(key, resource);

					let precedenceSet = resources.precedences.get(precedence);

					if (!precedenceSet) {
						precedenceSet = new Set();
						resources.precedences.set(precedence, precedenceSet);
						const emptyStyleResource = {
							type: 'style',
							chunks: [],
							state: NoState,
							props: {
								precedence,
								hrefs: [],
							},
						};
						precedenceSet.add(emptyStyleResource);

						resources.stylePrecedences.set(precedence, emptyStyleResource);
					}

					precedenceSet.add(resource);
				}

				if (resources.boundaryResources) {
					resources.boundaryResources.add(resource);
				}

				if (textEmbedded) {
					// This link follows text but we aren't writing a tag. while not as efficient as possible we need
					// to be safe and assume text will follow by inserting a textSeparator
					target.push(textSeparator);
				}

				return null;
			}
		} else if (props.onLoad || props.onError) {
			// When using load handlers we cannot hoist and need to emit links in place
			return pushLinkImpl(target, props);
		} else {
			// We can hoist this link so we may need to emit a text separator.
			// @TODO refactor text separators so we don't have to defensively add
			// them when we don't end up emitting a tag as a result of pushStartInstance
			if (textEmbedded) {
				// This link follows text but we aren't writing a tag. while not as efficient as possible we need
				// to be safe and assume text will follow by inserting a textSeparator
				target.push(textSeparator);
			}

			switch (props.rel) {
				case 'preconnect':
				case 'dns-prefetch':
					return pushLinkImpl(responseState.preconnectChunks, props);

				case 'preload':
					return pushLinkImpl(responseState.preloadChunks, props);

				default:
					return pushLinkImpl(responseState.hoistableChunks, props);
			}
		}
	}
}

function pushLinkImpl(target, props) {
	target.push(startChunkForTag('link'));

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
				case 'dangerouslySetInnerHTML':
					throw new Error(
						'link' +
							' is a self-closing tag and must neither have `children` nor ' +
							'use `dangerouslySetInnerHTML`.',
					);

				default:
					pushAttribute(target, propKey, propValue);
					break;
			}
		}
	}

	target.push(endOfStartTagSelfClosing);
	return null;
}

function pushStyle(
	target,
	props,
	resources,
	textEmbedded,
	insertionMode,
	noscriptTagInScope,
) {
	{
		const precedence = props.precedence;
		const href = props.href;

		if (
			insertionMode === SVG_MODE ||
			noscriptTagInScope ||
			props.itemProp != null ||
			typeof precedence !== 'string' ||
			typeof href !== 'string' ||
			href === ''
		) {
			// This style tag is not able to be turned into a Style Resource
			return pushStyleImpl(target, props);
		}

		const key = getResourceKey('style', href);
		let resource = resources.stylesMap.get(key);

		if (!resource) {
			resource = resources.stylePrecedences.get(precedence);

			if (!resource) {
				resource = {
					type: 'style',
					chunks: [],
					state: NoState,
					props: {
						precedence,
						hrefs: [href],
					},
				};
				resources.stylePrecedences.set(precedence, resource);
				const precedenceSet = new Set();
				precedenceSet.add(resource);

				resources.precedences.set(precedence, precedenceSet);
			} else {
				resource.props.hrefs.push(href);
			}

			resources.stylesMap.set(key, resource);

			if (resources.boundaryResources) {
				resources.boundaryResources.add(resource);
			}

			pushStyleContents(resource.chunks, props);
		}

		if (textEmbedded) {
			// This link follows text but we aren't writing a tag. while not as efficient as possible we need
			// to be safe and assume text will follow by inserting a textSeparator
			target.push(textSeparator);
		}
	}
}

function pushStyleImpl(target, props) {
	target.push(startChunkForTag('style'));
	let children = null;
	let innerHTML = null;

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
					children = propValue;
					break;

				case 'dangerouslySetInnerHTML':
					innerHTML = propValue;
					break;

				default:
					pushAttribute(target, propKey, propValue);
					break;
			}
		}
	}

	target.push(endOfStartTag);
	const child = Array.isArray(children)
		? children.length < 2
			? children[0]
			: null
		: children;

	if (
		typeof child !== 'function' &&
		typeof child !== 'symbol' &&
		child !== null &&
		child !== undefined
	) {
		// eslint-disable-next-line react-internal/safe-string-coercion
		target.push(stringToChunk(escapeTextForBrowser('' + child)));
	}

	pushInnerHTML(target, innerHTML, children);
	target.push(endTag1, stringToChunk('style'), endTag2);
	return null;
}

function pushStyleContents(target, props) {
	let children = null;
	let innerHTML = null;

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
					children = propValue;
					break;

				case 'dangerouslySetInnerHTML':
					innerHTML = propValue;
					break;
			}
		}
	}

	const child = Array.isArray(children)
		? children.length < 2
			? children[0]
			: null
		: children;

	if (
		typeof child !== 'function' &&
		typeof child !== 'symbol' &&
		child !== null &&
		child !== undefined
	) {
		// eslint-disable-next-line react-internal/safe-string-coercion
		target.push(stringToChunk(escapeTextForBrowser('' + child)));
	}

	pushInnerHTML(target, innerHTML, children);
	return;
}

function pushSelfClosing(target, props, tag) {
	target.push(startChunkForTag(tag));

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
				case 'dangerouslySetInnerHTML':
					throw new Error(
						tag +
							' is a self-closing tag and must neither have `children` nor ' +
							'use `dangerouslySetInnerHTML`.',
					);

				default:
					pushAttribute(target, propKey, propValue);
					break;
			}
		}
	}

	target.push(endOfStartTagSelfClosing);
	return null;
}

function pushStartMenuItem(target, props) {
	target.push(startChunkForTag('menuitem'));

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
				case 'dangerouslySetInnerHTML':
					throw new Error(
						'menuitems cannot have `children` nor `dangerouslySetInnerHTML`.',
					);

				default:
					pushAttribute(target, propKey, propValue);
					break;
			}
		}
	}

	target.push(endOfStartTag);
	return null;
}

function pushTitle(
	target,
	props,
	responseState,
	insertionMode,
	noscriptTagInScope,
) {
	{
		if (
			insertionMode !== SVG_MODE &&
			!noscriptTagInScope &&
			props.itemProp == null
		) {
			pushTitleImpl(responseState.hoistableChunks, props);
			return null;
		} else {
			return pushTitleImpl(target, props);
		}
	}
}

function pushTitleImpl(target, props) {
	target.push(startChunkForTag('title'));
	let children = null;
	let innerHTML = null;

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
					children = propValue;
					break;

				case 'dangerouslySetInnerHTML':
					innerHTML = propValue;
					break;

				default:
					pushAttribute(target, propKey, propValue);
					break;
			}
		}
	}

	target.push(endOfStartTag);
	const child = Array.isArray(children)
		? children.length < 2
			? children[0]
			: null
		: children;

	if (
		typeof child !== 'function' &&
		typeof child !== 'symbol' &&
		child !== null &&
		child !== undefined
	) {
		// eslint-disable-next-line react-internal/safe-string-coercion
		target.push(stringToChunk(escapeTextForBrowser('' + child)));
	}

	pushInnerHTML(target, innerHTML, children);
	target.push(endTag1, stringToChunk('title'), endTag2);
	return null;
}

function pushStartHead(target, props, responseState, insertionMode) {
	{
		if (insertionMode < HTML_MODE && responseState.headChunks === null) {
			// This <head> is the Document.head and should be part of the preamble
			responseState.headChunks = [];
			return pushStartGenericElement(responseState.headChunks, props, 'head');
		} else {
			// This <head> is deep and is likely just an error. we emit it inline though.
			// Validation should warn that this tag is the the wrong spot.
			return pushStartGenericElement(target, props, 'head');
		}
	}
}

function pushStartHtml(target, props, responseState, insertionMode) {
	{
		if (insertionMode === ROOT_HTML_MODE && responseState.htmlChunks === null) {
			// This <html> is the Document.documentElement and should be part of the preamble
			responseState.htmlChunks = [DOCTYPE];
			return pushStartGenericElement(responseState.htmlChunks, props, 'html');
		} else {
			// This <html> is deep and is likely just an error. we emit it inline though.
			// Validation should warn that this tag is the the wrong spot.
			return pushStartGenericElement(target, props, 'html');
		}
	}
}

function pushScript(
	target,
	props,
	resources,
	textEmbedded,
	insertionMode,
	noscriptTagInScope,
) {
	{
		const asyncProp = props.async;

		if (
			typeof props.src !== 'string' ||
			!props.src ||
			!(
				asyncProp &&
				typeof asyncProp !== 'function' &&
				typeof asyncProp !== 'symbol'
			) ||
			props.onLoad ||
			props.onError ||
			insertionMode === SVG_MODE ||
			noscriptTagInScope ||
			props.itemProp != null
		) {
			// This script will not be a resource, we bailout early and emit it in place.
			return pushScriptImpl(target, props);
		}

		const src = props.src;
		const key = getResourceKey('script', src); // We can make this <script> into a ScriptResource

		let resource = resources.scriptsMap.get(key);

		if (!resource) {
			resource = {
				type: 'script',
				chunks: [],
				state: NoState,
				props: null,
			};
			resources.scriptsMap.set(key, resource);

			resources.scripts.add(resource);
			let scriptProps = props;
			const preloadResource = resources.preloadsMap.get(key);

			if (preloadResource) {
				// If we already had a preload we don't want that resource to flush directly.
				// We let the newly created resource govern flushing.
				preloadResource.state |= Blocked;
				scriptProps = assign({}, props);
				adoptPreloadPropsForScriptProps(scriptProps, preloadResource.props);
			} // encode the tag as Chunks

			pushScriptImpl(resource.chunks, scriptProps);
		}

		if (textEmbedded) {
			// This script follows text but we aren't writing a tag. while not as efficient as possible we need
			// to be safe and assume text will follow by inserting a textSeparator
			target.push(textSeparator);
		}

		return null;
	}
}

function pushScriptImpl(target, props) {
	target.push(startChunkForTag('script'));
	let children = null;
	let innerHTML = null;

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
					children = propValue;
					break;

				case 'dangerouslySetInnerHTML':
					innerHTML = propValue;
					break;

				default:
					pushAttribute(target, propKey, propValue);
					break;
			}
		}
	}

	target.push(endOfStartTag);

	pushInnerHTML(target, innerHTML, children);

	if (typeof children === 'string') {
		target.push(stringToChunk(encodeHTMLTextNode(children)));
	}

	target.push(endTag1, stringToChunk('script'), endTag2);
	return null;
}

function pushStartGenericElement(target, props, tag) {
	target.push(startChunkForTag(tag));
	let children = null;
	let innerHTML = null;

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
					children = propValue;
					break;

				case 'dangerouslySetInnerHTML':
					innerHTML = propValue;
					break;

				default:
					pushAttribute(target, propKey, propValue);
					break;
			}
		}
	}

	target.push(endOfStartTag);
	pushInnerHTML(target, innerHTML, children);

	if (typeof children === 'string') {
		// Special case children as a string to avoid the unnecessary comment.
		// TODO: Remove this special case after the general optimization is in place.
		target.push(stringToChunk(encodeHTMLTextNode(children)));
		return null;
	}

	return children;
}

function pushStartCustomElement(target, props, tag) {
	target.push(startChunkForTag(tag));
	let children = null;
	let innerHTML = null;

	for (let propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			let propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
					children = propValue;
					break;

				case 'dangerouslySetInnerHTML':
					innerHTML = propValue;
					break;

				case 'style':
					pushStyleAttribute(target, propValue);
					break;

				case 'suppressContentEditableWarning':
				case 'suppressHydrationWarning':
					// Ignored. These are built-in to React on the client.
					break;

				default:
					if (
						isAttributeNameSafe(propKey) &&
						typeof propValue !== 'function' &&
						typeof propValue !== 'symbol'
					) {
						target.push(
							attributeSeparator,
							stringToChunk(propKey),
							attributeAssign,
							stringToChunk(escapeTextForBrowser(propValue)),
							attributeEnd,
						);
					}

					break;
			}
		}
	}

	target.push(endOfStartTag);
	pushInnerHTML(target, innerHTML, children);
	return children;
}

const leadingNewline = stringToPrecomputedChunk('\n');

function pushStartPreformattedElement(target, props, tag) {
	target.push(startChunkForTag(tag));
	let children = null;
	let innerHTML = null;

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'children':
					children = propValue;
					break;

				case 'dangerouslySetInnerHTML':
					innerHTML = propValue;
					break;

				default:
					pushAttribute(target, propKey, propValue);
					break;
			}
		}
	}

	target.push(endOfStartTag); // text/html ignores the first character in these tags if it's a newline
	// Prefer to break application/xml over text/html (for now) by adding
	// a newline specifically to get eaten by the parser. (Alternately for
	// textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	// \r is normalized out by HTMLTextAreaElement#value.)
	// See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	// See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	// See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	// See: Parsing of "textarea" "listing" and "pre" elements
	//  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	// TODO: This doesn't deal with the case where the child is an array
	// or component that returns a string.

	if (innerHTML != null) {
		if (children != null) {
			throw new Error(
				'Can only set one of `children` or `props.dangerouslySetInnerHTML`.',
			);
		}

		if (typeof innerHTML !== 'object' || !('__html' in innerHTML)) {
			throw new Error(
				'`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' +
					'Please visit https://reactjs.org/link/dangerously-set-inner-html ' +
					'for more information.',
			);
		}

		const html = innerHTML.__html;

		if (html !== null && html !== undefined) {
			if (typeof html === 'string' && html.length > 0 && html[0] === '\n') {
				target.push(leadingNewline, stringToChunk(html));
			} else {
				target.push(stringToChunk('' + html));
			}
		}
	}

	if (typeof children === 'string' && children[0] === '\n') {
		target.push(leadingNewline);
	}

	return children;
} // We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

const VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset

const validatedTagCache = new Map();

function startChunkForTag(tag) {
	let tagStartChunk = validatedTagCache.get(tag);

	if (tagStartChunk === undefined) {
		if (!VALID_TAG_REGEX.test(tag)) {
			throw new Error('Invalid tag: ' + tag);
		}

		tagStartChunk = stringToPrecomputedChunk('<' + tag);
		validatedTagCache.set(tag, tagStartChunk);
	}

	return tagStartChunk;
}

const DOCTYPE = stringToPrecomputedChunk('<!DOCTYPE html>');
function pushStartInstance(
	target,
	type,
	props,
	resources,
	responseState,
	formatContext,
	textEmbedded,
) {
	switch (type) {
		case 'div':
		case 'span':
		case 'svg':
		case 'path':
		case 'a':
		case 'g':
		case 'p':
		case 'li':
			// Fast track very common tags
			break;
		// Special tags

		case 'select':
			return pushStartSelect(target, props);

		case 'option':
			return pushStartOption(target, props, formatContext);

		case 'textarea':
			return pushStartTextArea(target, props);

		case 'input':
			return pushInput(target, props, responseState);

		case 'button':
			return pushStartButton(target, props, responseState);

		case 'form':
			return pushStartForm(target, props);

		case 'menuitem':
			return pushStartMenuItem(target, props);

		case 'title':
			return pushTitle(
				target,
				props,
				responseState,
				formatContext.insertionMode,
				formatContext.noscriptTagInScope,
			);

		case 'link':
			return pushLink(
				target,
				props,
				responseState,
				resources,
				textEmbedded,
				formatContext.insertionMode,
				formatContext.noscriptTagInScope,
			);

		case 'script':
			return pushScript(
				target,
				props,
				resources,
				textEmbedded,
				formatContext.insertionMode,
				formatContext.noscriptTagInScope,
			);

		case 'style':
			return pushStyle(
				target,
				props,
				resources,
				textEmbedded,
				formatContext.insertionMode,
				formatContext.noscriptTagInScope,
			);

		case 'meta':
			return pushMeta(
				target,
				props,
				responseState,
				textEmbedded,
				formatContext.insertionMode,
				formatContext.noscriptTagInScope,
			);
		// Newline eating tags

		case 'listing':
		case 'pre': {
			return pushStartPreformattedElement(target, props, type);
		}
		// Omitted close tags

		case 'base':
		case 'area':
		case 'br':
		case 'col':
		case 'embed':
		case 'hr':
		case 'img':
		case 'keygen':
		case 'param':
		case 'source':
		case 'track':
		case 'wbr': {
			return pushSelfClosing(target, props, type);
		}
		// These are reserved SVG and MathML elements, that are never custom elements.
		// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts

		case 'annotation-xml':
		case 'color-profile':
		case 'font-face':
		case 'font-face-src':
		case 'font-face-uri':
		case 'font-face-format':
		case 'font-face-name':
		case 'missing-glyph': {
			break;
		}
		// Preamble start tags

		case 'head':
			return pushStartHead(
				target,
				props,
				responseState,
				formatContext.insertionMode,
			);

		case 'html': {
			return pushStartHtml(
				target,
				props,
				responseState,
				formatContext.insertionMode,
			);
		}

		default: {
			if (type.indexOf('-') !== -1) {
				// Custom element
				return pushStartCustomElement(target, props, type);
			}
		}
	} // Generic element

	return pushStartGenericElement(target, props, type);
}
const endTag1 = stringToPrecomputedChunk('</');
const endTag2 = stringToPrecomputedChunk('>');
function pushEndInstance(target, type, props, responseState, formatContext) {
	switch (type) {
		// When float is on we expect title and script tags to always be pushed in
		// a unit and never return children. when we end up pushing the end tag we
		// want to ensure there is no extra closing tag pushed
		case 'title':
		case 'style':
		case 'script':
		// Omitted close tags
		// TODO: Instead of repeating this switch we could try to pass a flag from above.
		// That would require returning a tuple. Which might be ok if it gets inlined.

		case 'area':
		case 'base':
		case 'br':
		case 'col':
		case 'embed':
		case 'hr':
		case 'img':
		case 'input':
		case 'keygen':
		case 'link':
		case 'meta':
		case 'param':
		case 'source':
		case 'track':
		case 'wbr': {
			// No close tag needed.
			return;
		}
		// Postamble end tags
		// When float is enabled we omit the end tags for body and html when
		// they represent the Document.body and Document.documentElement Nodes.
		// This is so we can withhold them until the postamble when we know
		// we won't emit any more tags

		case 'body': {
			if (formatContext.insertionMode <= HTML_HTML_MODE) {
				responseState.hasBody = true;
				return;
			}

			break;
		}

		case 'html':
			if (formatContext.insertionMode === ROOT_HTML_MODE) {
				return;
			}

			break;
	}

	target.push(endTag1, stringToChunk(type), endTag2);
}

function writeBootstrap(destination, responseState) {
	const bootstrapChunks = responseState.bootstrapChunks;
	let i = 0;

	for (; i < bootstrapChunks.length - 1; i++) {
		writeChunk(destination, bootstrapChunks[i]);
	}

	if (i < bootstrapChunks.length) {
		const lastChunk = bootstrapChunks[i];
		bootstrapChunks.length = 0;
		return writeChunkAndReturn(destination, lastChunk);
	}

	return true;
}

function writeCompletedRoot(destination, responseState) {
	return writeBootstrap(destination, responseState);
} // Structural Nodes
// A placeholder is a node inside a hidden partial tree that can be filled in later, but before
// display. It's never visible to users. We use the template tag because it can be used in every
// type of parent. <script> tags also work in every other tag except <colgroup>.

const placeholder1 = stringToPrecomputedChunk('<template id="');
const placeholder2 = stringToPrecomputedChunk('"></template>');
function writePlaceholder(destination, responseState, id) {
	writeChunk(destination, placeholder1);
	writeChunk(destination, responseState.placeholderPrefix);
	const formattedID = stringToChunk(id.toString(16));
	writeChunk(destination, formattedID);
	return writeChunkAndReturn(destination, placeholder2);
} // Suspense boundaries are encoded as comments.

const startCompletedSuspenseBoundary = stringToPrecomputedChunk('<!--$-->');
const startPendingSuspenseBoundary1 = stringToPrecomputedChunk(
	'<!--$?--><template id="',
);
const startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
const startClientRenderedSuspenseBoundary =
	stringToPrecomputedChunk('<!--$!-->');
const endSuspenseBoundary = stringToPrecomputedChunk('<!--/$-->');
const clientRenderedSuspenseBoundaryError1 =
	stringToPrecomputedChunk('<template');
const clientRenderedSuspenseBoundaryErrorAttrInterstitial =
	stringToPrecomputedChunk('"');
const clientRenderedSuspenseBoundaryError1A =
	stringToPrecomputedChunk(' data-dgst="');
stringToPrecomputedChunk(' data-msg="');
stringToPrecomputedChunk(' data-stck="');
const clientRenderedSuspenseBoundaryError2 =
	stringToPrecomputedChunk('></template>');
function writeStartCompletedSuspenseBoundary(destination, responseState) {
	return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
}
function writeStartPendingSuspenseBoundary(destination, responseState, id) {
	writeChunk(destination, startPendingSuspenseBoundary1);

	if (id === null) {
		throw new Error(
			'An ID must have been assigned before we can complete the boundary.',
		);
	}

	writeChunk(destination, id);
	return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
}
function writeStartClientRenderedSuspenseBoundary(
	destination,
	responseState,
	errorDigest,
	errorMesssage,
	errorComponentStack,
) {
	let result;
	result = writeChunkAndReturn(
		destination,
		startClientRenderedSuspenseBoundary,
	);
	writeChunk(destination, clientRenderedSuspenseBoundaryError1);

	if (errorDigest) {
		writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
		writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
		writeChunk(
			destination,
			clientRenderedSuspenseBoundaryErrorAttrInterstitial,
		);
	}

	result = writeChunkAndReturn(
		destination,
		clientRenderedSuspenseBoundaryError2,
	);
	return result;
}
function writeEndCompletedSuspenseBoundary(destination, responseState) {
	return writeChunkAndReturn(destination, endSuspenseBoundary);
}
function writeEndPendingSuspenseBoundary(destination, responseState) {
	return writeChunkAndReturn(destination, endSuspenseBoundary);
}
function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
	return writeChunkAndReturn(destination, endSuspenseBoundary);
}
const startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
const startSegmentHTML2 = stringToPrecomputedChunk('">');
const endSegmentHTML = stringToPrecomputedChunk('</div>');
const startSegmentSVG = stringToPrecomputedChunk(
	'<svg aria-hidden="true" style="display:none" id="',
);
const startSegmentSVG2 = stringToPrecomputedChunk('">');
const endSegmentSVG = stringToPrecomputedChunk('</svg>');
const startSegmentMathML = stringToPrecomputedChunk(
	'<math aria-hidden="true" style="display:none" id="',
);
const startSegmentMathML2 = stringToPrecomputedChunk('">');
const endSegmentMathML = stringToPrecomputedChunk('</math>');
const startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
const startSegmentTable2 = stringToPrecomputedChunk('">');
const endSegmentTable = stringToPrecomputedChunk('</table>');
const startSegmentTableBody = stringToPrecomputedChunk(
	'<table hidden><tbody id="',
);
const startSegmentTableBody2 = stringToPrecomputedChunk('">');
const endSegmentTableBody = stringToPrecomputedChunk('</tbody></table>');
const startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
const startSegmentTableRow2 = stringToPrecomputedChunk('">');
const endSegmentTableRow = stringToPrecomputedChunk('</tr></table>');
const startSegmentColGroup = stringToPrecomputedChunk(
	'<table hidden><colgroup id="',
);
const startSegmentColGroup2 = stringToPrecomputedChunk('">');
const endSegmentColGroup = stringToPrecomputedChunk('</colgroup></table>');
function writeStartSegment(destination, responseState, formatContext, id) {
	switch (formatContext.insertionMode) {
		case ROOT_HTML_MODE:
		case HTML_HTML_MODE:
		case HTML_MODE: {
			writeChunk(destination, startSegmentHTML);
			writeChunk(destination, responseState.segmentPrefix);
			writeChunk(destination, stringToChunk(id.toString(16)));
			return writeChunkAndReturn(destination, startSegmentHTML2);
		}

		case SVG_MODE: {
			writeChunk(destination, startSegmentSVG);
			writeChunk(destination, responseState.segmentPrefix);
			writeChunk(destination, stringToChunk(id.toString(16)));
			return writeChunkAndReturn(destination, startSegmentSVG2);
		}

		case MATHML_MODE: {
			writeChunk(destination, startSegmentMathML);
			writeChunk(destination, responseState.segmentPrefix);
			writeChunk(destination, stringToChunk(id.toString(16)));
			return writeChunkAndReturn(destination, startSegmentMathML2);
		}

		case HTML_TABLE_MODE: {
			writeChunk(destination, startSegmentTable);
			writeChunk(destination, responseState.segmentPrefix);
			writeChunk(destination, stringToChunk(id.toString(16)));
			return writeChunkAndReturn(destination, startSegmentTable2);
		}
		// TODO: For the rest of these, there will be extra wrapper nodes that never
		// get deleted from the document. We need to delete the table too as part
		// of the injected scripts. They are invisible though so it's not too terrible
		// and it's kind of an edge case to suspend in a table. Totally supported though.

		case HTML_TABLE_BODY_MODE: {
			writeChunk(destination, startSegmentTableBody);
			writeChunk(destination, responseState.segmentPrefix);
			writeChunk(destination, stringToChunk(id.toString(16)));
			return writeChunkAndReturn(destination, startSegmentTableBody2);
		}

		case HTML_TABLE_ROW_MODE: {
			writeChunk(destination, startSegmentTableRow);
			writeChunk(destination, responseState.segmentPrefix);
			writeChunk(destination, stringToChunk(id.toString(16)));
			return writeChunkAndReturn(destination, startSegmentTableRow2);
		}

		case HTML_COLGROUP_MODE: {
			writeChunk(destination, startSegmentColGroup);
			writeChunk(destination, responseState.segmentPrefix);
			writeChunk(destination, stringToChunk(id.toString(16)));
			return writeChunkAndReturn(destination, startSegmentColGroup2);
		}

		default: {
			throw new Error('Unknown insertion mode. This is a bug in React.');
		}
	}
}
function writeEndSegment(destination, formatContext) {
	switch (formatContext.insertionMode) {
		case ROOT_HTML_MODE:
		case HTML_HTML_MODE:
		case HTML_MODE: {
			return writeChunkAndReturn(destination, endSegmentHTML);
		}

		case SVG_MODE: {
			return writeChunkAndReturn(destination, endSegmentSVG);
		}

		case MATHML_MODE: {
			return writeChunkAndReturn(destination, endSegmentMathML);
		}

		case HTML_TABLE_MODE: {
			return writeChunkAndReturn(destination, endSegmentTable);
		}

		case HTML_TABLE_BODY_MODE: {
			return writeChunkAndReturn(destination, endSegmentTableBody);
		}

		case HTML_TABLE_ROW_MODE: {
			return writeChunkAndReturn(destination, endSegmentTableRow);
		}

		case HTML_COLGROUP_MODE: {
			return writeChunkAndReturn(destination, endSegmentColGroup);
		}

		default: {
			throw new Error('Unknown insertion mode. This is a bug in React.');
		}
	}
}
const completeSegmentScript1Full = stringToPrecomputedChunk(
	completeSegment + ';$RS("',
);
const completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
const completeSegmentScript2 = stringToPrecomputedChunk('","');
const completeSegmentScriptEnd = stringToPrecomputedChunk('")</script>');
const completeSegmentData1 = stringToPrecomputedChunk(
	'<template data-rsi="" data-sid="',
);
const completeSegmentData2 = stringToPrecomputedChunk('" data-pid="');
const completeSegmentDataEnd = dataElementQuotedEnd;
function writeCompletedSegmentInstruction(
	destination,
	responseState,
	contentSegmentID,
) {
	const scriptFormat = responseState.streamingFormat === ScriptStreamingFormat;

	if (scriptFormat) {
		writeChunk(destination, responseState.startInlineScript);

		if (
			(responseState.instructions & SentCompleteSegmentFunction) ===
			NothingSent
		) {
			// The first time we write this, we'll need to include the full implementation.
			responseState.instructions |= SentCompleteSegmentFunction;
			writeChunk(destination, completeSegmentScript1Full);
		} else {
			// Future calls can just reuse the same function.
			writeChunk(destination, completeSegmentScript1Partial);
		}
	} else {
		writeChunk(destination, completeSegmentData1);
	} // Write function arguments, which are string literals

	writeChunk(destination, responseState.segmentPrefix);
	const formattedID = stringToChunk(contentSegmentID.toString(16));
	writeChunk(destination, formattedID);

	if (scriptFormat) {
		writeChunk(destination, completeSegmentScript2);
	} else {
		writeChunk(destination, completeSegmentData2);
	}

	writeChunk(destination, responseState.placeholderPrefix);
	writeChunk(destination, formattedID);

	if (scriptFormat) {
		return writeChunkAndReturn(destination, completeSegmentScriptEnd);
	} else {
		return writeChunkAndReturn(destination, completeSegmentDataEnd);
	}
}
const completeBoundaryScript1Full = stringToPrecomputedChunk(
	completeBoundary + '$RC("',
);
const completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
const completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(
	completeBoundary + completeBoundaryWithStyles + '$RR("',
);
const completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(
	completeBoundaryWithStyles + '$RR("',
);
const completeBoundaryWithStylesScript1Partial =
	stringToPrecomputedChunk('$RR("');
const completeBoundaryScript2 = stringToPrecomputedChunk('","');
const completeBoundaryScript3a = stringToPrecomputedChunk('",');
const completeBoundaryScript3b = stringToPrecomputedChunk('"');
const completeBoundaryScriptEnd = stringToPrecomputedChunk(')</script>');
const completeBoundaryData1 = stringToPrecomputedChunk(
	'<template data-rci="" data-bid="',
);
const completeBoundaryWithStylesData1 = stringToPrecomputedChunk(
	'<template data-rri="" data-bid="',
);
const completeBoundaryData2 = stringToPrecomputedChunk('" data-sid="');
const completeBoundaryData3a = stringToPrecomputedChunk('" data-sty="');
const completeBoundaryDataEnd = dataElementQuotedEnd;
function writeCompletedBoundaryInstruction(
	destination,
	responseState,
	boundaryID,
	contentSegmentID,
	boundaryResources,
) {
	let requiresStyleInsertion;

	{
		requiresStyleInsertion = responseState.stylesToHoist; // If necessary stylesheets will be flushed with this instruction.
		// Any style tags not yet hoisted in the Document will also be hoisted.
		// We reset this state since after this instruction executes all styles
		// up to this point will have been hoisted

		responseState.stylesToHoist = false;
	}

	const scriptFormat = responseState.streamingFormat === ScriptStreamingFormat;

	if (scriptFormat) {
		writeChunk(destination, responseState.startInlineScript);

		if (requiresStyleInsertion) {
			if (
				(responseState.instructions & SentCompleteBoundaryFunction) ===
				NothingSent
			) {
				responseState.instructions |=
					SentStyleInsertionFunction | SentCompleteBoundaryFunction;
				writeChunk(
					destination,
					clonePrecomputedChunk(completeBoundaryWithStylesScript1FullBoth),
				);
			} else if (
				(responseState.instructions & SentStyleInsertionFunction) ===
				NothingSent
			) {
				responseState.instructions |= SentStyleInsertionFunction;
				writeChunk(destination, completeBoundaryWithStylesScript1FullPartial);
			} else {
				writeChunk(destination, completeBoundaryWithStylesScript1Partial);
			}
		} else {
			if (
				(responseState.instructions & SentCompleteBoundaryFunction) ===
				NothingSent
			) {
				responseState.instructions |= SentCompleteBoundaryFunction;
				writeChunk(destination, completeBoundaryScript1Full);
			} else {
				writeChunk(destination, completeBoundaryScript1Partial);
			}
		}
	} else {
		if (requiresStyleInsertion) {
			writeChunk(destination, completeBoundaryWithStylesData1);
		} else {
			writeChunk(destination, completeBoundaryData1);
		}
	}

	if (boundaryID === null) {
		throw new Error(
			'An ID must have been assigned before we can complete the boundary.',
		);
	} // Write function arguments, which are string and array literals

	const formattedContentID = stringToChunk(contentSegmentID.toString(16));
	writeChunk(destination, boundaryID);

	if (scriptFormat) {
		writeChunk(destination, completeBoundaryScript2);
	} else {
		writeChunk(destination, completeBoundaryData2);
	}

	writeChunk(destination, responseState.segmentPrefix);
	writeChunk(destination, formattedContentID);

	if (requiresStyleInsertion) {
		// Script and data writers must format this differently:
		//  - script writer emits an array literal, whose string elements are
		//    escaped for javascript  e.g. ["A", "B"]
		//  - data writer emits a string literal, which is escaped as html
		//    e.g. [&#34;A&#34;, &#34;B&#34;]
		if (scriptFormat) {
			writeChunk(destination, completeBoundaryScript3a); // boundaryResources encodes an array literal

			writeStyleResourceDependenciesInJS(destination, boundaryResources);
		} else {
			writeChunk(destination, completeBoundaryData3a);
			writeStyleResourceDependenciesInAttr(destination, boundaryResources);
		}
	} else {
		if (scriptFormat) {
			writeChunk(destination, completeBoundaryScript3b);
		}
	}

	let writeMore;

	if (scriptFormat) {
		writeMore = writeChunkAndReturn(destination, completeBoundaryScriptEnd);
	} else {
		writeMore = writeChunkAndReturn(destination, completeBoundaryDataEnd);
	}

	return writeBootstrap(destination, responseState) && writeMore;
}
const clientRenderScript1Full = stringToPrecomputedChunk(
	clientRenderBoundary + ';$RX("',
);
const clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
const clientRenderScript1A = stringToPrecomputedChunk('"');
const clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(',');
const clientRenderScriptEnd = stringToPrecomputedChunk(')</script>');
const clientRenderData1 = stringToPrecomputedChunk(
	'<template data-rxi="" data-bid="',
);
const clientRenderData2 = stringToPrecomputedChunk('" data-dgst="');
const clientRenderData3 = stringToPrecomputedChunk('" data-msg="');
const clientRenderData4 = stringToPrecomputedChunk('" data-stck="');
const clientRenderDataEnd = dataElementQuotedEnd;
function writeClientRenderBoundaryInstruction(
	destination,
	responseState,
	boundaryID,
	errorDigest,
	errorMessage,
	errorComponentStack,
) {
	const scriptFormat = responseState.streamingFormat === ScriptStreamingFormat;

	if (scriptFormat) {
		writeChunk(destination, responseState.startInlineScript);

		if (
			(responseState.instructions & SentClientRenderFunction) ===
			NothingSent
		) {
			// The first time we write this, we'll need to include the full implementation.
			responseState.instructions |= SentClientRenderFunction;
			writeChunk(destination, clientRenderScript1Full);
		} else {
			// Future calls can just reuse the same function.
			writeChunk(destination, clientRenderScript1Partial);
		}
	} else {
		// <template data-rxi="" data-bid="
		writeChunk(destination, clientRenderData1);
	}

	if (boundaryID === null) {
		throw new Error(
			'An ID must have been assigned before we can complete the boundary.',
		);
	}

	writeChunk(destination, boundaryID);

	if (scriptFormat) {
		// " needs to be inserted for scripts, since ArgInterstitual does not contain
		// leading or trailing quotes
		writeChunk(destination, clientRenderScript1A);
	}

	if (errorDigest || errorMessage || errorComponentStack) {
		if (scriptFormat) {
			// ,"JSONString"
			writeChunk(destination, clientRenderErrorScriptArgInterstitial);
			writeChunk(
				destination,
				stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || '')),
			);
		} else {
			// " data-dgst="HTMLString
			writeChunk(destination, clientRenderData2);
			writeChunk(
				destination,
				stringToChunk(escapeTextForBrowser(errorDigest || '')),
			);
		}
	}

	if (errorMessage || errorComponentStack) {
		if (scriptFormat) {
			// ,"JSONString"
			writeChunk(destination, clientRenderErrorScriptArgInterstitial);
			writeChunk(
				destination,
				stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || '')),
			);
		} else {
			// " data-msg="HTMLString
			writeChunk(destination, clientRenderData3);
			writeChunk(
				destination,
				stringToChunk(escapeTextForBrowser(errorMessage || '')),
			);
		}
	}

	if (errorComponentStack) {
		// ,"JSONString"
		if (scriptFormat) {
			writeChunk(destination, clientRenderErrorScriptArgInterstitial);
			writeChunk(
				destination,
				stringToChunk(
					escapeJSStringsForInstructionScripts(errorComponentStack),
				),
			);
		} else {
			// " data-stck="HTMLString
			writeChunk(destination, clientRenderData4);
			writeChunk(
				destination,
				stringToChunk(escapeTextForBrowser(errorComponentStack)),
			);
		}
	}

	if (scriptFormat) {
		// ></script>
		return writeChunkAndReturn(destination, clientRenderScriptEnd);
	} else {
		// "></template>
		return writeChunkAndReturn(destination, clientRenderDataEnd);
	}
}
const regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g;

function escapeJSStringsForInstructionScripts(input) {
	const escaped = JSON.stringify(input);
	return escaped.replace(regexForJSStringsInInstructionScripts, (match) => {
		switch (match) {
			// santizing breaking out of strings and script tags
			case '<':
				return '\\u003c';

			case '\u2028':
				return '\\u2028';

			case '\u2029':
				return '\\u2029';

			default: {
				// eslint-disable-next-line react-internal/prod-error-codes
				throw new Error(
					'escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React',
				);
			}
		}
	});
}

const regexForJSStringsInScripts = /[&><\u2028\u2029]/g;

function escapeJSObjectForInstructionScripts(input) {
	const escaped = JSON.stringify(input);
	return escaped.replace(regexForJSStringsInScripts, (match) => {
		switch (match) {
			// santizing breaking out of strings and script tags
			case '&':
				return '\\u0026';

			case '>':
				return '\\u003e';

			case '<':
				return '\\u003c';

			case '\u2028':
				return '\\u2028';

			case '\u2029':
				return '\\u2029';

			default: {
				// eslint-disable-next-line react-internal/prod-error-codes
				throw new Error(
					'escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React',
				);
			}
		}
	});
}

const lateStyleTagResourceOpen1 = stringToPrecomputedChunk(
	'<style media="not all" data-precedence="',
);
const lateStyleTagResourceOpen2 = stringToPrecomputedChunk('" data-href="');
const lateStyleTagResourceOpen3 = stringToPrecomputedChunk('">');
const lateStyleTagTemplateClose = stringToPrecomputedChunk('</style>'); // Tracks whether the boundary currently flushing is flushign style tags or has any
// stylesheet dependencies not flushed in the Preamble.

let currentlyRenderingBoundaryHasStylesToHoist = false; // Acts as a return value for the forEach execution of style tag flushing.

let destinationHasCapacity = true;

function flushStyleTagsLateForBoundary(resource) {
	if (
		resource.type === 'stylesheet' &&
		(resource.state & FlushedInPreamble) === NoState
	) {
		currentlyRenderingBoundaryHasStylesToHoist = true;
	} else if (resource.type === 'style') {
		const chunks = resource.chunks;
		const hrefs = resource.props.hrefs;
		let i = 0;

		if (chunks.length) {
			writeChunk(this, lateStyleTagResourceOpen1);
			writeChunk(
				this,
				stringToChunk(escapeTextForBrowser(resource.props.precedence)),
			);

			if (hrefs.length) {
				writeChunk(this, lateStyleTagResourceOpen2);

				for (; i < hrefs.length - 1; i++) {
					writeChunk(this, stringToChunk(escapeTextForBrowser(hrefs[i])));
					writeChunk(this, spaceSeparator);
				}

				writeChunk(this, stringToChunk(escapeTextForBrowser(hrefs[i])));
			}

			writeChunk(this, lateStyleTagResourceOpen3);

			for (i = 0; i < chunks.length; i++) {
				writeChunk(this, chunks[i]);
			}

			destinationHasCapacity = writeChunkAndReturn(
				this,
				lateStyleTagTemplateClose,
			); // We wrote style tags for this boundary and we may need to emit a script
			// to hoist them.

			currentlyRenderingBoundaryHasStylesToHoist = true; // style resources can flush continuously since more rules may be written into
			// them with new hrefs. Instead of marking it flushed, we simply reset the chunks
			// and hrefs

			chunks.length = 0;
			hrefs.length = 0;
		}
	}
}

function writeResourcesForBoundary(
	destination,
	boundaryResources,
	responseState,
) {
	// Reset these on each invocation, they are only safe to read in this function
	currentlyRenderingBoundaryHasStylesToHoist = false;
	destinationHasCapacity = true; // Flush each Boundary resource

	boundaryResources.forEach(flushStyleTagsLateForBoundary, destination);

	if (currentlyRenderingBoundaryHasStylesToHoist) {
		responseState.stylesToHoist = true;
	}

	return destinationHasCapacity;
}

function flushResourceInPreamble(resource) {
	if ((resource.state & (Flushed | Blocked)) === NoState) {
		const chunks = resource.chunks;

		for (let i = 0; i < chunks.length; i++) {
			writeChunk(this, chunks[i]);
		}

		resource.state |= FlushedInPreamble;
	}
}

function flushResourceLate(resource) {
	if ((resource.state & (Flushed | Blocked)) === NoState) {
		const chunks = resource.chunks;

		for (let i = 0; i < chunks.length; i++) {
			writeChunk(this, chunks[i]);
		}

		resource.state |= FlushedLate;
	}
} // This must always be read after flushing stylesheet styles. we know we will encounter a style resource
// per precedence and it will be set before ready so we cast this to avoid an extra check at runtime

let precedenceStyleTagResource = null; // This flags let's us opt out of flushing a placeholder style tag to emit the precedence in the right order.
// If a stylesheet was flushed then we have the precedence order preserved and only need to emit <style> tags
// if there are actual chunks to flush

let didFlushPrecedence = false;

function flushStyleInPreamble(resource, key, set) {
	const chunks = resource.chunks;

	if (resource.state & Flushed) {
		// In theory this should never happen because we clear from the
		// Set on flush but to ensure correct semantics we don't emit
		// anything if we are in this state.
		set.delete(resource);
	} else {
		// We can emit this style or stylesheet as is.
		if (resource.type === 'style') {
			precedenceStyleTagResource = resource;
			return;
		} // We still need to encode stylesheet chunks
		// because unlike most Hoistables and Resources we do not eagerly encode
		// them during render. This is because if we flush late we have to send a
		// different encoding and we don't want to encode multiple times

		pushLinkImpl(chunks, resource.props);

		for (let i = 0; i < chunks.length; i++) {
			writeChunk(this, chunks[i]);
		}

		resource.state |= FlushedInPreamble;
		didFlushPrecedence = true;
	}
}

const styleTagResourceOpen1 = stringToPrecomputedChunk(
	'<style data-precedence="',
);
const styleTagResourceOpen2 = stringToPrecomputedChunk('" data-href="');
const spaceSeparator = stringToPrecomputedChunk(' ');
const styleTagResourceOpen3 = stringToPrecomputedChunk('">');
const styleTagResourceClose = stringToPrecomputedChunk('</style>');

function flushAllStylesInPreamble(set, precedence) {
	didFlushPrecedence = false;
	set.forEach(flushStyleInPreamble, this);
	set.clear();
	const chunks = precedenceStyleTagResource.chunks;
	const hrefs = precedenceStyleTagResource.props.hrefs;

	if (didFlushPrecedence === false || chunks.length) {
		writeChunk(this, styleTagResourceOpen1);
		writeChunk(this, stringToChunk(escapeTextForBrowser(precedence)));
		let i = 0;

		if (hrefs.length) {
			writeChunk(this, styleTagResourceOpen2);

			for (; i < hrefs.length - 1; i++) {
				writeChunk(this, stringToChunk(escapeTextForBrowser(hrefs[i])));
				writeChunk(this, spaceSeparator);
			}

			writeChunk(this, stringToChunk(escapeTextForBrowser(hrefs[i])));
		}

		writeChunk(this, styleTagResourceOpen3);

		for (i = 0; i < chunks.length; i++) {
			writeChunk(this, chunks[i]);
		}

		writeChunk(this, styleTagResourceClose); // style resources can flush continuously since more rules may be written into
		// them with new hrefs. Instead of marking it flushed, we simply reset the chunks
		// and hrefs

		chunks.length = 0;
		hrefs.length = 0;
	}
}

function preloadLateStyle(resource) {
	if (resource.state & PreloadFlushed) {
		// This resource has already had a preload flushed
		return;
	}

	if (resource.type === 'style') {
		// <style> tags do not need to be preloaded
		return;
	}

	const chunks = resource.chunks;
	const preloadProps = preloadAsStylePropsFromProps(
		resource.props.href,
		resource.props,
	);
	pushLinkImpl(chunks, preloadProps);

	for (let i = 0; i < chunks.length; i++) {
		writeChunk(this, chunks[i]);
	}

	resource.state |= PreloadFlushed;
	chunks.length = 0;
}

function preloadLateStyles(set, precedence) {
	set.forEach(preloadLateStyle, this);
	set.clear();
} // We don't bother reporting backpressure at the moment because we expect to
// flush the entire preamble in a single pass. This probably should be modified
// in the future to be backpressure sensitive but that requires a larger refactor
// of the flushing code in Fizz.

function writePreamble(
	destination,
	resources,
	responseState,
	willFlushAllSegments,
) {
	// This function must be called exactly once on every request
	if (!willFlushAllSegments && responseState.externalRuntimeScript) {
		// If the root segment is incomplete due to suspended tasks
		// (e.g. willFlushAllSegments = false) and we are using data
		// streaming format, ensure the external runtime is sent.
		// (User code could choose to send this even earlier by calling
		//  preinit(...), if they know they will suspend).
		const _responseState$extern = responseState.externalRuntimeScript,
			src = _responseState$extern.src,
			chunks = _responseState$extern.chunks;
		internalPreinitScript(resources, src, chunks);
	}

	const htmlChunks = responseState.htmlChunks;
	const headChunks = responseState.headChunks;
	let i = 0; // Emit open tags before Hoistables and Resources

	if (htmlChunks) {
		// We have an <html> to emit as part of the preamble
		for (i = 0; i < htmlChunks.length; i++) {
			writeChunk(destination, htmlChunks[i]);
		}

		if (headChunks) {
			for (i = 0; i < headChunks.length; i++) {
				writeChunk(destination, headChunks[i]);
			}
		} else {
			// We did not render a head but we emitted an <html> so we emit one now
			writeChunk(destination, startChunkForTag('head'));
			writeChunk(destination, endOfStartTag);
		}
	} else if (headChunks) {
		// We do not have an <html> but we do have a <head>
		for (i = 0; i < headChunks.length; i++) {
			writeChunk(destination, headChunks[i]);
		}
	} // Emit high priority Hoistables

	const charsetChunks = responseState.charsetChunks;

	for (i = 0; i < charsetChunks.length; i++) {
		writeChunk(destination, charsetChunks[i]);
	}

	charsetChunks.length = 0; // emit preconnect resources

	resources.preconnects.forEach(flushResourceInPreamble, destination);
	resources.preconnects.clear();
	const preconnectChunks = responseState.preconnectChunks;

	for (i = 0; i < preconnectChunks.length; i++) {
		writeChunk(destination, preconnectChunks[i]);
	}

	preconnectChunks.length = 0;
	resources.fontPreloads.forEach(flushResourceInPreamble, destination);
	resources.fontPreloads.clear(); // Flush unblocked stylesheets by precedence

	resources.precedences.forEach(flushAllStylesInPreamble, destination);
	resources.scripts.forEach(flushResourceInPreamble, destination);
	resources.scripts.clear();
	resources.explicitStylesheetPreloads.forEach(
		flushResourceInPreamble,
		destination,
	);
	resources.explicitStylesheetPreloads.clear();
	resources.explicitScriptPreloads.forEach(
		flushResourceInPreamble,
		destination,
	);
	resources.explicitScriptPreloads.clear();
	resources.explicitOtherPreloads.forEach(flushResourceInPreamble, destination);
	resources.explicitOtherPreloads.clear(); // Write embedding preloadChunks

	const preloadChunks = responseState.preloadChunks;

	for (i = 0; i < preloadChunks.length; i++) {
		writeChunk(destination, preloadChunks[i]);
	}

	preloadChunks.length = 0; // Write embedding hoistableChunks

	const hoistableChunks = responseState.hoistableChunks;

	for (i = 0; i < hoistableChunks.length; i++) {
		writeChunk(destination, hoistableChunks[i]);
	}

	hoistableChunks.length = 0; // Flush closing head if necessary

	if (htmlChunks && headChunks === null) {
		// We have an <html> rendered but no <head> rendered. We however inserted
		// a <head> up above so we need to emit the </head> now. This is safe because
		// if the main content contained the </head> it would also have provided a
		// <head>. This means that all the content inside <html> is either <body> or
		// invalid HTML
		writeChunk(destination, endTag1);
		writeChunk(destination, stringToChunk('head'));
		writeChunk(destination, endTag2);
	}
} // We don't bother reporting backpressure at the moment because we expect to
// flush the entire preamble in a single pass. This probably should be modified
// in the future to be backpressure sensitive but that requires a larger refactor
// of the flushing code in Fizz.

function writeHoistables(destination, resources, responseState) {
	let i = 0; // Emit high priority Hoistables
	// We omit charsetChunks because we have already sent the shell and if it wasn't
	// already sent it is too late now.

	resources.preconnects.forEach(flushResourceLate, destination);
	resources.preconnects.clear();
	const preconnectChunks = responseState.preconnectChunks;

	for (i = 0; i < preconnectChunks.length; i++) {
		writeChunk(destination, preconnectChunks[i]);
	}

	preconnectChunks.length = 0;
	resources.fontPreloads.forEach(flushResourceLate, destination);
	resources.fontPreloads.clear(); // Preload any stylesheets. these will emit in a render instruction that follows this
	// but we want to kick off preloading as soon as possible

	resources.precedences.forEach(preloadLateStyles, destination);
	resources.scripts.forEach(flushResourceLate, destination);
	resources.scripts.clear();
	resources.explicitStylesheetPreloads.forEach(flushResourceLate, destination);
	resources.explicitStylesheetPreloads.clear();
	resources.explicitScriptPreloads.forEach(flushResourceLate, destination);
	resources.explicitScriptPreloads.clear();
	resources.explicitOtherPreloads.forEach(flushResourceLate, destination);
	resources.explicitOtherPreloads.clear(); // Write embedding preloadChunks

	const preloadChunks = responseState.preloadChunks;

	for (i = 0; i < preloadChunks.length; i++) {
		writeChunk(destination, preloadChunks[i]);
	}

	preloadChunks.length = 0; // Write embedding hoistableChunks

	const hoistableChunks = responseState.hoistableChunks;

	for (i = 0; i < hoistableChunks.length; i++) {
		writeChunk(destination, hoistableChunks[i]);
	}

	hoistableChunks.length = 0;
}
function writePostamble(destination, responseState) {
	if (responseState.hasBody) {
		writeChunk(destination, endTag1);
		writeChunk(destination, stringToChunk('body'));
		writeChunk(destination, endTag2);
	}

	if (responseState.htmlChunks) {
		writeChunk(destination, endTag1);
		writeChunk(destination, stringToChunk('html'));
		writeChunk(destination, endTag2);
	}
}
const arrayFirstOpenBracket = stringToPrecomputedChunk('[');
const arraySubsequentOpenBracket = stringToPrecomputedChunk(',[');
const arrayInterstitial = stringToPrecomputedChunk(',');
const arrayCloseBracket = stringToPrecomputedChunk(']'); // This function writes a 2D array of strings to be embedded in javascript.
// E.g.
//  [["JS_escaped_string1", "JS_escaped_string2"]]

function writeStyleResourceDependenciesInJS(destination, boundaryResources) {
	writeChunk(destination, arrayFirstOpenBracket);
	let nextArrayOpenBrackChunk = arrayFirstOpenBracket;
	boundaryResources.forEach((resource) => {
		if (resource.type === 'style');
		else if (resource.state & FlushedInPreamble);
		else if (resource.state & Flushed) {
			// We only need to emit the href because this resource flushed in an earlier
			// boundary already which encoded the attributes necessary to construct
			// the resource instance on the client.
			writeChunk(destination, nextArrayOpenBrackChunk);
			writeStyleResourceDependencyHrefOnlyInJS(
				destination,
				resource.props.href,
			);
			writeChunk(destination, arrayCloseBracket);
			nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
		} else if (resource.type === 'stylesheet') {
			// We need to emit the whole resource for insertion on the client
			writeChunk(destination, nextArrayOpenBrackChunk);
			writeStyleResourceDependencyInJS(
				destination,
				resource.props.href,
				resource.props['data-precedence'],
				resource.props,
			);
			writeChunk(destination, arrayCloseBracket);
			nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
			resource.state |= FlushedLate;
		}
	});
	writeChunk(destination, arrayCloseBracket);
}
/* Helper functions */

function writeStyleResourceDependencyHrefOnlyInJS(destination, href) {
	const coercedHref = '' + href;
	writeChunk(
		destination,
		stringToChunk(escapeJSObjectForInstructionScripts(coercedHref)),
	);
}

function writeStyleResourceDependencyInJS(
	destination,
	href,
	precedence,
	props,
) {
	// eslint-disable-next-line react-internal/safe-string-coercion
	const coercedHref = sanitizeURL('' + href);
	writeChunk(
		destination,
		stringToChunk(escapeJSObjectForInstructionScripts(coercedHref)),
	);

	const coercedPrecedence = '' + precedence;
	writeChunk(destination, arrayInterstitial);
	writeChunk(
		destination,
		stringToChunk(escapeJSObjectForInstructionScripts(coercedPrecedence)),
	);

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'href':
				case 'rel':
				case 'precedence':
				case 'data-precedence': {
					break;
				}

				case 'children':
				case 'dangerouslySetInnerHTML':
					throw new Error(
						'link' +
							' is a self-closing tag and must neither have `children` nor ' +
							'use `dangerouslySetInnerHTML`.',
					);

				default:
					writeStyleResourceAttributeInJS(destination, propKey, propValue);
					break;
			}
		}
	}

	return null;
}

function writeStyleResourceAttributeInJS(destination, name, value) {
	// not null or undefined
	let attributeName = name.toLowerCase();
	let attributeValue;

	switch (typeof value) {
		case 'function':
		case 'symbol':
			return;
	}

	switch (name) {
		// Reserved names
		case 'innerHTML':
		case 'dangerouslySetInnerHTML':
		case 'suppressContentEditableWarning':
		case 'suppressHydrationWarning':
		case 'style':
			// Ignored
			return;
		// Attribute renames

		case 'className': {
			attributeName = 'class';

			attributeValue = '' + value;
			break;
		}
		// Booleans

		case 'hidden': {
			if (value === false) {
				return;
			}

			attributeValue = '';
			break;
		}
		// Santized URLs

		case 'src':
		case 'href': {
			value = sanitizeURL(value);

			attributeValue = '' + value;
			break;
		}

		default: {
			if (
				// unrecognized event handlers are not SSR'd and we (apparently)
				// use on* as hueristic for these handler props
				name.length > 2 &&
				(name[0] === 'o' || name[0] === 'O') &&
				(name[1] === 'n' || name[1] === 'N')
			) {
				return;
			}

			if (!isAttributeNameSafe(name)) {
				return;
			}

			attributeValue = '' + value;
		}
	}

	writeChunk(destination, arrayInterstitial);
	writeChunk(
		destination,
		stringToChunk(escapeJSObjectForInstructionScripts(attributeName)),
	);
	writeChunk(destination, arrayInterstitial);
	writeChunk(
		destination,
		stringToChunk(escapeJSObjectForInstructionScripts(attributeValue)),
	);
} // This function writes a 2D array of strings to be embedded in an attribute
// value and read with JSON.parse in ReactDOMServerExternalRuntime.js
// E.g.
//  [[&quot;JSON_escaped_string1&quot;, &quot;JSON_escaped_string2&quot;]]

function writeStyleResourceDependenciesInAttr(destination, boundaryResources) {
	writeChunk(destination, arrayFirstOpenBracket);
	let nextArrayOpenBrackChunk = arrayFirstOpenBracket;
	boundaryResources.forEach((resource) => {
		if (resource.type === 'style');
		else if (resource.state & FlushedInPreamble);
		else if (resource.state & Flushed) {
			// We only need to emit the href because this resource flushed in an earlier
			// boundary already which encoded the attributes necessary to construct
			// the resource instance on the client.
			writeChunk(destination, nextArrayOpenBrackChunk);
			writeStyleResourceDependencyHrefOnlyInAttr(
				destination,
				resource.props.href,
			);
			writeChunk(destination, arrayCloseBracket);
			nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
		} else if (resource.type === 'stylesheet') {
			// We need to emit the whole resource for insertion on the client
			writeChunk(destination, nextArrayOpenBrackChunk);
			writeStyleResourceDependencyInAttr(
				destination,
				resource.props.href,
				resource.props['data-precedence'],
				resource.props,
			);
			writeChunk(destination, arrayCloseBracket);
			nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
			resource.state |= FlushedLate;
		}
	});
	writeChunk(destination, arrayCloseBracket);
}
/* Helper functions */

function writeStyleResourceDependencyHrefOnlyInAttr(destination, href) {
	const coercedHref = '' + href;
	writeChunk(
		destination,
		stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref))),
	);
}

function writeStyleResourceDependencyInAttr(
	destination,
	href,
	precedence,
	props,
) {
	// eslint-disable-next-line react-internal/safe-string-coercion
	const coercedHref = sanitizeURL('' + href);
	writeChunk(
		destination,
		stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref))),
	);

	const coercedPrecedence = '' + precedence;
	writeChunk(destination, arrayInterstitial);
	writeChunk(
		destination,
		stringToChunk(escapeTextForBrowser(JSON.stringify(coercedPrecedence))),
	);

	for (const propKey in props) {
		if (hasOwnProperty.call(props, propKey)) {
			const propValue = props[propKey];

			if (propValue == null) {
				continue;
			}

			switch (propKey) {
				case 'href':
				case 'rel':
				case 'precedence':
				case 'data-precedence': {
					break;
				}

				case 'children':
				case 'dangerouslySetInnerHTML':
					throw new Error(
						'link' +
							' is a self-closing tag and must neither have `children` nor ' +
							'use `dangerouslySetInnerHTML`.',
					);

				default:
					writeStyleResourceAttributeInAttr(destination, propKey, propValue);
					break;
			}
		}
	}

	return null;
}

function writeStyleResourceAttributeInAttr(destination, name, value) {
	// not null or undefined
	let attributeName = name.toLowerCase();
	let attributeValue;

	switch (typeof value) {
		case 'function':
		case 'symbol':
			return;
	}

	switch (name) {
		// Reserved names
		case 'innerHTML':
		case 'dangerouslySetInnerHTML':
		case 'suppressContentEditableWarning':
		case 'suppressHydrationWarning':
		case 'style':
			// Ignored
			return;
		// Attribute renames

		case 'className': {
			attributeName = 'class';

			attributeValue = '' + value;
			break;
		}
		// Booleans

		case 'hidden': {
			if (value === false) {
				return;
			}

			attributeValue = '';
			break;
		}
		// Santized URLs

		case 'src':
		case 'href': {
			value = sanitizeURL(value);

			attributeValue = '' + value;
			break;
		}

		default: {
			if (
				// unrecognized event handlers are not SSR'd and we (apparently)
				// use on* as hueristic for these handler props
				name.length > 2 &&
				(name[0] === 'o' || name[0] === 'O') &&
				(name[1] === 'n' || name[1] === 'N')
			) {
				return;
			}

			if (!isAttributeNameSafe(name)) {
				return;
			}

			attributeValue = '' + value;
		}
	}

	writeChunk(destination, arrayInterstitial);
	writeChunk(
		destination,
		stringToChunk(escapeTextForBrowser(JSON.stringify(attributeName))),
	);
	writeChunk(destination, arrayInterstitial);
	writeChunk(
		destination,
		stringToChunk(escapeTextForBrowser(JSON.stringify(attributeValue))),
	);
}
/**
 * Resources
 */

const NoState =
	/*            */
	0b0000; // These tags indicate whether the Resource was flushed and in which phase

const FlushedInPreamble =
	/*  */
	0b0001;
const FlushedLate =
	/*        */
	0b0010;
const Flushed =
	/*            */
	0b0011; // This tag indicates whether this Resource is blocked from flushing.
// This currently is only used with stylesheets that are blocked by a Boundary

const Blocked =
	/*            */
	0b0100; // This tag indicates whether this Resource has been preloaded.
// This generally only makes sense for Resources other than PreloadResource

const PreloadFlushed =
	/*     */
	0b1000; // Dev extensions.
// Stylesheets and Scripts rendered with jsx
// Preloads, Stylesheets, and Scripts from ReactDOM.preload or ReactDOM.preinit
// Preloads created for normal components we rendered but know we can preload early such as
// sync Scripts and stylesheets without precedence or with onLoad/onError handlers
// @TODO add bootstrap script to implicit preloads

function createResources() {
	return {
		// persistent
		preloadsMap: new Map(),
		preconnectsMap: new Map(),
		stylesMap: new Map(),
		scriptsMap: new Map(),
		// cleared on flush
		preconnects: new Set(),
		fontPreloads: new Set(),
		// usedImagePreloads: new Set(),
		precedences: new Map(),
		stylePrecedences: new Map(),
		scripts: new Set(),
		explicitStylesheetPreloads: new Set(),
		// explicitImagePreloads: new Set(),
		explicitScriptPreloads: new Set(),
		explicitOtherPreloads: new Set(),
		// like a module global for currently rendering boundary
		boundaryResources: null,
	};
}
function createBoundaryResources() {
	return new Set();
}
function setCurrentlyRenderingBoundaryResourcesTarget(
	resources,
	boundaryResources,
) {
	resources.boundaryResources = boundaryResources;
}

function getResourceKey(as, href) {
	return '[' + as + ']' + href;
}

function prefetchDNS(href, options) {
	const request = resolveRequest();

	if (!request) {
		// In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also
		// possibly get them from the stack if we are not in an async context. Since we were not able to resolve
		// the resources for this call in either case we opt to do nothing. We can consider making this a warning
		// but there may be times where calling a function outside of render is intentional (i.e. to warm up data
		// fetching) and we don't want to warn in those cases.
		return;
	}

	const resources = getResources(request);

	if (typeof href === 'string' && href) {
		const key = getResourceKey('prefetchDNS', href);
		let resource = resources.preconnectsMap.get(key);

		if (!resource) {
			resource = {
				type: 'preconnect',
				chunks: [],
				state: NoState,
				props: null,
			};
			resources.preconnectsMap.set(key, resource);
			pushLinkImpl(resource.chunks, {
				href,
				rel: 'dns-prefetch',
			});
		}

		resources.preconnects.add(resource);
		flushResources(request);
	}
}
function preconnect(href, options) {
	const request = resolveRequest();

	if (!request) {
		// In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also
		// possibly get them from the stack if we are not in an async context. Since we were not able to resolve
		// the resources for this call in either case we opt to do nothing. We can consider making this a warning
		// but there may be times where calling a function outside of render is intentional (i.e. to warm up data
		// fetching) and we don't want to warn in those cases.
		return;
	}

	const resources = getResources(request);

	if (typeof href === 'string' && href) {
		const crossOrigin =
			options == null || typeof options.crossOrigin !== 'string'
				? null
				: options.crossOrigin === 'use-credentials'
					? 'use-credentials'
					: '';
		const key =
			'[preconnect][' +
			(crossOrigin === null ? 'null' : crossOrigin) +
			']' +
			href;
		let resource = resources.preconnectsMap.get(key);

		if (!resource) {
			resource = {
				type: 'preconnect',
				chunks: [],
				state: NoState,
				props: null,
			};
			resources.preconnectsMap.set(key, resource);
			pushLinkImpl(resource.chunks, {
				rel: 'preconnect',
				href,
				crossOrigin,
			});
		}

		resources.preconnects.add(resource);
		flushResources(request);
	}
}
function preload(href, options) {
	const request = resolveRequest();

	if (!request) {
		// In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also
		// possibly get them from the stack if we are not in an async context. Since we were not able to resolve
		// the resources for this call in either case we opt to do nothing. We can consider making this a warning
		// but there may be times where calling a function outside of render is intentional (i.e. to warm up data
		// fetching) and we don't want to warn in those cases.
		return;
	}

	const resources = getResources(request);

	if (
		typeof href === 'string' &&
		href &&
		typeof options === 'object' &&
		options !== null &&
		typeof options.as === 'string' &&
		options.as
	) {
		const as = options.as;
		let key;

		if (as === 'image') {
			// For image preloads the key contains either the imageSrcSet + imageSizes or the href but not
			// both. This is to prevent identical calls with the same srcSet and sizes to be duplicated
			// by varying the href. this is an edge case but it is the most correct behavior.
			const imageSrcSet = options.imageSrcSet,
				imageSizes = options.imageSizes;
			let uniquePart = '';

			if (typeof imageSrcSet === 'string' && imageSrcSet !== '') {
				uniquePart += '[' + imageSrcSet + ']';

				if (typeof imageSizes === 'string') {
					uniquePart += '[' + imageSizes + ']';
				}
			} else {
				uniquePart += '[][]' + href;
			}

			key = getResourceKey(as, uniquePart);
		} else {
			key = getResourceKey(as, href);
		}

		let resource = resources.preloadsMap.get(key);

		if (!resource) {
			resource = {
				type: 'preload',
				chunks: [],
				state: NoState,
				props: preloadPropsFromPreloadOptions(href, as, options),
			};
			resources.preloadsMap.set(key, resource);

			pushLinkImpl(resource.chunks, resource.props);
		}

		switch (as) {
			case 'font': {
				resources.fontPreloads.add(resource);
				break;
			}

			case 'style': {
				resources.explicitStylesheetPreloads.add(resource);
				break;
			}

			case 'script': {
				resources.explicitScriptPreloads.add(resource);
				break;
			}

			default: {
				resources.explicitOtherPreloads.add(resource);
			}
		}

		flushResources(request);
	}
}

function preinit(href, options) {
	const request = resolveRequest();

	if (!request) {
		// In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also
		// possibly get them from the stack if we are not in an async context. Since we were not able to resolve
		// the resources for this call in either case we opt to do nothing. We can consider making this a warning
		// but there may be times where calling a function outside of render is intentional (i.e. to warm up data
		// fetching) and we don't want to warn in those cases.
		return;
	}

	const resources = getResources(request);

	if (
		typeof href === 'string' &&
		href &&
		typeof options === 'object' &&
		options !== null
	) {
		const as = options.as;

		switch (as) {
			case 'style': {
				const key = getResourceKey(as, href);
				let resource = resources.stylesMap.get(key);
				const precedence = options.precedence || 'default';

				if (!resource) {
					let state = NoState;
					const preloadResource = resources.preloadsMap.get(key);

					if (preloadResource && preloadResource.state & Flushed) {
						state = PreloadFlushed;
					}

					resource = {
						type: 'stylesheet',
						chunks: [],
						state,
						props: stylesheetPropsFromPreinitOptions(href, precedence, options),
					};
					resources.stylesMap.set(key, resource);

					let precedenceSet = resources.precedences.get(precedence);

					if (!precedenceSet) {
						precedenceSet = new Set();
						resources.precedences.set(precedence, precedenceSet);
						const emptyStyleResource = {
							type: 'style',
							chunks: [],
							state: NoState,
							props: {
								precedence,
								hrefs: [],
							},
						};
						precedenceSet.add(emptyStyleResource);

						resources.stylePrecedences.set(precedence, emptyStyleResource);
					}

					precedenceSet.add(resource);
					flushResources(request);
				}

				return;
			}

			case 'script': {
				const src = href;
				const key = getResourceKey(as, src);
				let resource = resources.scriptsMap.get(key);

				if (!resource) {
					resource = {
						type: 'script',
						chunks: [],
						state: NoState,
						props: null,
					};
					resources.scriptsMap.set(key, resource);
					const resourceProps = scriptPropsFromPreinitOptions(src, options);

					resources.scripts.add(resource);
					pushScriptImpl(resource.chunks, resourceProps);
					flushResources(request);
				}

				return;
			}
		}
	}
} // This function is only safe to call at Request start time since it assumes
// that each script has not already been preloaded. If we find a need to preload
// scripts at any other point in time we will need to check whether the preload
// already exists and not assume it

function preloadBootstrapScript(resources, src, nonce, integrity, crossOrigin) {
	const key = getResourceKey('script', src);

	const props = {
		rel: 'preload',
		href: src,
		as: 'script',
		nonce,
		integrity,
		crossOrigin,
	};
	const resource = {
		type: 'preload',
		chunks: [],
		state: NoState,
		props,
	};
	resources.preloadsMap.set(key, resource);
	resources.explicitScriptPreloads.add(resource);
	pushLinkImpl(resource.chunks, props);
} // This function is only safe to call at Request start time since it assumes
// that each module has not already been preloaded. If we find a need to preload
// scripts at any other point in time we will need to check whether the preload
// already exists and not assume it

function preloadBootstrapModule(resources, src, nonce, integrity, crossOrigin) {
	const key = getResourceKey('script', src);

	const props = {
		rel: 'modulepreload',
		href: src,
		nonce,
		integrity,
		crossOrigin,
	};
	const resource = {
		type: 'preload',
		chunks: [],
		state: NoState,
		props,
	};
	resources.preloadsMap.set(key, resource);
	resources.explicitScriptPreloads.add(resource);
	pushLinkImpl(resource.chunks, props);
	return;
}

function internalPreinitScript(resources, src, chunks) {
	const key = getResourceKey('script', src);
	let resource = resources.scriptsMap.get(key);

	if (!resource) {
		resource = {
			type: 'script',
			chunks,
			state: NoState,
			props: null,
		};
		resources.scriptsMap.set(key, resource);
		resources.scripts.add(resource);
	}

	return;
}

function preloadPropsFromPreloadOptions(href, as, options) {
	return {
		rel: 'preload',
		as,
		// There is a bug in Safari where imageSrcSet is not respected on preload links
		// so we omit the href here if we have imageSrcSet b/c safari will load the wrong image.
		// This harms older browers that do not support imageSrcSet by making their preloads not work
		// but this population is shrinking fast and is already small so we accept this tradeoff.
		href: as === 'image' && options.imageSrcSet ? undefined : href,
		crossOrigin: as === 'font' ? '' : options.crossOrigin,
		integrity: options.integrity,
		type: options.type,
		nonce: options.nonce,
		fetchPriority: options.fetchPriority,
		imageSrcSet: options.imageSrcSet,
		imageSizes: options.imageSizes,
		referrerPolicy: options.referrerPolicy,
	};
}

function preloadAsStylePropsFromProps(href, props) {
	return {
		rel: 'preload',
		as: 'style',
		href: href,
		crossOrigin: props.crossOrigin,
		fetchPriority: props.fetchPriority,
		integrity: props.integrity,
		media: props.media,
		hrefLang: props.hrefLang,
		referrerPolicy: props.referrerPolicy,
	};
}

function stylesheetPropsFromPreinitOptions(href, precedence, options) {
	return {
		rel: 'stylesheet',
		href,
		'data-precedence': precedence,
		crossOrigin: options.crossOrigin,
		integrity: options.integrity,
		fetchPriority: options.fetchPriority,
	};
}

function stylesheetPropsFromRawProps(rawProps) {
	return assign({}, rawProps, {
		'data-precedence': rawProps.precedence,
		precedence: null,
	});
}

function adoptPreloadPropsForStylesheetProps(resourceProps, preloadProps) {
	if (resourceProps.crossOrigin == null)
		resourceProps.crossOrigin = preloadProps.crossOrigin;
	if (resourceProps.integrity == null)
		resourceProps.integrity = preloadProps.integrity;
}

function scriptPropsFromPreinitOptions(src, options) {
	return {
		src,
		async: true,
		crossOrigin: options.crossOrigin,
		integrity: options.integrity,
		nonce: options.nonce,
		fetchPriority: options.fetchPriority,
	};
}

function adoptPreloadPropsForScriptProps(resourceProps, preloadProps) {
	if (resourceProps.crossOrigin == null)
		resourceProps.crossOrigin = preloadProps.crossOrigin;
	if (resourceProps.integrity == null)
		resourceProps.integrity = preloadProps.integrity;
}

function hoistStyleResource(resource) {
	this.add(resource);
}

function hoistResources(resources, source) {
	const currentBoundaryResources = resources.boundaryResources;

	if (currentBoundaryResources) {
		source.forEach(hoistStyleResource, currentBoundaryResources);
	}
}

const supportsRequestStorage = typeof AsyncLocalStorage === 'function';
const requestStorage = supportsRequestStorage ? new AsyncLocalStorage() : null;

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types.
const REACT_ELEMENT_TYPE = Symbol.for('react.element');
const REACT_PORTAL_TYPE = Symbol.for('react.portal');
const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
const REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
const REACT_PROFILER_TYPE = Symbol.for('react.profiler');
const REACT_PROVIDER_TYPE = Symbol.for('react.provider');
const REACT_CONTEXT_TYPE = Symbol.for('react.context');
const REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
const REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
const REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
const REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
const REACT_MEMO_TYPE = Symbol.for('react.memo');
const REACT_LAZY_TYPE = Symbol.for('react.lazy');
const REACT_SCOPE_TYPE = Symbol.for('react.scope');
const REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');
const REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
const REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');
const REACT_CACHE_TYPE = Symbol.for('react.cache');
const REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(
	'react.default_value',
);
const MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
const FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
	if (maybeIterable === null || typeof maybeIterable !== 'object') {
		return null;
	}

	const maybeIterator =
		(MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
		maybeIterable[FAUX_ITERATOR_SYMBOL];

	if (typeof maybeIterator === 'function') {
		return maybeIterator;
	}

	return null;
}

function getWrappedName(outerType, innerType, wrapperName) {
	const displayName = outerType.displayName;

	if (displayName) {
		return displayName;
	}

	const functionName = innerType.displayName || innerType.name || '';
	return functionName !== ''
		? wrapperName + '(' + functionName + ')'
		: wrapperName;
} // Keep in sync with react-reconciler/getComponentNameFromFiber

function getContextName(type) {
	return type.displayName || 'Context';
} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.

function getComponentNameFromType(type) {
	if (type == null) {
		// Host root, text node or just invalid type.
		return null;
	}

	if (typeof type === 'function') {
		return type.displayName || type.name || null;
	}

	if (typeof type === 'string') {
		return type;
	}

	switch (type) {
		case REACT_FRAGMENT_TYPE:
			return 'Fragment';

		case REACT_PORTAL_TYPE:
			return 'Portal';

		case REACT_PROFILER_TYPE:
			return 'Profiler';

		case REACT_STRICT_MODE_TYPE:
			return 'StrictMode';

		case REACT_SUSPENSE_TYPE:
			return 'Suspense';

		case REACT_SUSPENSE_LIST_TYPE:
			return 'SuspenseList';

		case REACT_CACHE_TYPE: {
			return 'Cache';
		}
	}

	if (typeof type === 'object') {
		switch (type.$$typeof) {
			case REACT_CONTEXT_TYPE:
				const context = type;
				return getContextName(context) + '.Consumer';

			case REACT_PROVIDER_TYPE:
				const provider = type;
				return getContextName(provider._context) + '.Provider';

			case REACT_FORWARD_REF_TYPE:
				return getWrappedName(type, type.render, 'ForwardRef');

			case REACT_MEMO_TYPE:
				const outerName = type.displayName || null;

				if (outerName !== null) {
					return outerName;
				}

				return getComponentNameFromType(type.type) || 'Memo';

			case REACT_LAZY_TYPE: {
				const lazyComponent = type;
				const payload = lazyComponent._payload;
				const init = lazyComponent._init;

				try {
					return getComponentNameFromType(init(payload));
				} catch (x) {
					return null;
				}
			}

			case REACT_SERVER_CONTEXT_TYPE: {
				const context2 = type;
				return (context2.displayName || context2._globalName) + '.Provider';
			}
		}
	}

	return null;
}

const emptyContextObject = {};

function getMaskedContext(type, unmaskedContext) {
	{
		const contextTypes = type.contextTypes;

		if (!contextTypes) {
			return emptyContextObject;
		}

		const context = {};

		for (const key in contextTypes) {
			context[key] = unmaskedContext[key];
		}

		return context;
	}
}
function processChildContext(instance, type, parentContext, childContextTypes) {
	{
		// TODO (bvaughn) Replace this behavior with an invariant() in the future.
		// It has only been added in Fiber to match the (unintentional) behavior in Stack.
		if (typeof instance.getChildContext !== 'function') {
			return parentContext;
		}

		const childContext = instance.getChildContext();

		for (const contextKey in childContext) {
			if (!(contextKey in childContextTypes)) {
				throw new Error(
					(getComponentNameFromType(type) || 'Unknown') +
						'.getChildContext(): key "' +
						contextKey +
						'" is not defined in childContextTypes.',
				);
			}
		}

		return assign({}, parentContext, childContext);
	}
}

// Forming a reverse tree.
// The structure of a context snapshot is an implementation of this file.
// Currently, it's implemented as tracking the current active node.

const rootContextSnapshot = null; // We assume that this runtime owns the "current" field on all ReactContext instances.
// This global (actually thread local) state represents what state all those "current",
// fields are currently in.

let currentActiveSnapshot = null;

function popNode(prev) {
	{
		prev.context._currentValue = prev.parentValue;
	}
}

function pushNode(next) {
	{
		next.context._currentValue = next.value;
	}
}

function popToNearestCommonAncestor(prev, next) {
	if (prev === next);
	else {
		popNode(prev);
		const parentPrev = prev.parent;
		const parentNext = next.parent;

		if (parentPrev === null) {
			if (parentNext !== null) {
				throw new Error(
					'The stacks must reach the root at the same time. This is a bug in React.',
				);
			}
		} else {
			if (parentNext === null) {
				throw new Error(
					'The stacks must reach the root at the same time. This is a bug in React.',
				);
			}

			popToNearestCommonAncestor(parentPrev, parentNext);
		} // On the way back, we push the new ones that weren't common.

		pushNode(next);
	}
}

function popAllPrevious(prev) {
	popNode(prev);
	const parentPrev = prev.parent;

	if (parentPrev !== null) {
		popAllPrevious(parentPrev);
	}
}

function pushAllNext(next) {
	const parentNext = next.parent;

	if (parentNext !== null) {
		pushAllNext(parentNext);
	}

	pushNode(next);
}

function popPreviousToCommonLevel(prev, next) {
	popNode(prev);
	const parentPrev = prev.parent;

	if (parentPrev === null) {
		throw new Error(
			'The depth must equal at least at zero before reaching the root. This is a bug in React.',
		);
	}

	if (parentPrev.depth === next.depth) {
		// We found the same level. Now we just need to find a shared ancestor.
		popToNearestCommonAncestor(parentPrev, next);
	} else {
		// We must still be deeper.
		popPreviousToCommonLevel(parentPrev, next);
	}
}

function popNextToCommonLevel(prev, next) {
	const parentNext = next.parent;

	if (parentNext === null) {
		throw new Error(
			'The depth must equal at least at zero before reaching the root. This is a bug in React.',
		);
	}

	if (prev.depth === parentNext.depth) {
		// We found the same level. Now we just need to find a shared ancestor.
		popToNearestCommonAncestor(prev, parentNext);
	} else {
		// We must still be deeper.
		popNextToCommonLevel(prev, parentNext);
	}

	pushNode(next);
} // Perform context switching to the new snapshot.
// To make it cheap to read many contexts, while not suspending, we make the switch eagerly by
// updating all the context's current values. That way reads, always just read the current value.
// At the cost of updating contexts even if they're never read by this subtree.

function switchContext(newSnapshot) {
	// The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.
	// We also need to update any new contexts that are now on the stack with the deepest value.
	// The easiest way to update new contexts is to just reapply them in reverse order from the
	// perspective of the backpointers. To avoid allocating a lot when switching, we use the stack
	// for that. Therefore this algorithm is recursive.
	// 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.
	// 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.
	// 3) Then we reapply new contexts on the way back up the stack.
	const prev = currentActiveSnapshot;
	const next = newSnapshot;

	if (prev !== next) {
		if (prev === null) {
			// $FlowFixMe[incompatible-call]: This has to be non-null since it's not equal to prev.
			pushAllNext(next);
		} else if (next === null) {
			popAllPrevious(prev);
		} else if (prev.depth === next.depth) {
			popToNearestCommonAncestor(prev, next);
		} else if (prev.depth > next.depth) {
			popPreviousToCommonLevel(prev, next);
		} else {
			popNextToCommonLevel(prev, next);
		}

		currentActiveSnapshot = next;
	}
}
function pushProvider(context, nextValue) {
	let prevValue;

	{
		prevValue = context._currentValue;
		context._currentValue = nextValue;
	}

	const prevNode = currentActiveSnapshot;
	const newNode = {
		parent: prevNode,
		depth: prevNode === null ? 0 : prevNode.depth + 1,
		context: context,
		parentValue: prevValue,
		value: nextValue,
	};
	currentActiveSnapshot = newNode;
	return newNode;
}
function popProvider(context) {
	const prevSnapshot = currentActiveSnapshot;

	if (prevSnapshot === null) {
		throw new Error(
			'Tried to pop a Context at the root of the app. This is a bug in React.',
		);
	}

	{
		const value = prevSnapshot.parentValue;

		if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
			prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
		} else {
			prevSnapshot.context._currentValue = value;
		}
	}

	return (currentActiveSnapshot = prevSnapshot.parent);
}
function getActiveContext() {
	return currentActiveSnapshot;
}
function readContext$1(context) {
	const value = context._currentValue;
	return value;
}

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */
function get(key) {
	return key._reactInternals;
}
function set(key, value) {
	key._reactInternals = value;
}

const classComponentUpdater = {
	isMounted(inst) {
		return false;
	},

	// $FlowFixMe[missing-local-annot]
	enqueueSetState(inst, payload, callback) {
		const internals = get(inst);

		if (internals.queue === null);
		else {
			internals.queue.push(payload);
		}
	},

	enqueueReplaceState(inst, payload, callback) {
		const internals = get(inst);
		internals.replace = true;
		internals.queue = [payload];
	},

	// $FlowFixMe[missing-local-annot]
	enqueueForceUpdate(inst, callback) {},
};

function applyDerivedStateFromProps(
	instance,
	ctor,
	getDerivedStateFromProps,
	prevState,
	nextProps,
) {
	const partialState = getDerivedStateFromProps(nextProps, prevState);

	const newState =
		partialState === null || partialState === undefined
			? prevState
			: assign({}, prevState, partialState);
	return newState;
}

function constructClassInstance(ctor, props, maskedLegacyContext) {
	let context = emptyContextObject;
	const contextType = ctor.contextType;

	if (typeof contextType === 'object' && contextType !== null) {
		context = readContext$1(contextType);
	} else {
		context = maskedLegacyContext;
	}

	const instance = new ctor(props, context);

	return instance;
}

function callComponentWillMount(type, instance) {
	const oldState = instance.state;

	if (typeof instance.componentWillMount === 'function') {
		instance.componentWillMount();
	}

	if (typeof instance.UNSAFE_componentWillMount === 'function') {
		instance.UNSAFE_componentWillMount();
	}

	if (oldState !== instance.state) {
		classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
	}
}

function processUpdateQueue(
	internalInstance,
	inst,
	props,
	maskedLegacyContext,
) {
	if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
		const oldQueue = internalInstance.queue;
		const oldReplace = internalInstance.replace;
		internalInstance.queue = null;
		internalInstance.replace = false;

		if (oldReplace && oldQueue.length === 1) {
			inst.state = oldQueue[0];
		} else {
			let nextState = oldReplace ? oldQueue[0] : inst.state;
			let dontMutate = true;

			for (let i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
				const partial = oldQueue[i];
				const partialState =
					typeof partial === 'function'
						? partial.call(inst, nextState, props, maskedLegacyContext)
						: partial;

				if (partialState != null) {
					if (dontMutate) {
						dontMutate = false;
						nextState = assign({}, nextState, partialState);
					} else {
						assign(nextState, partialState);
					}
				}
			}

			inst.state = nextState;
		}
	} else {
		internalInstance.queue = null;
	}
} // Invokes the mount life-cycles on a previously never rendered instance.

function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
	const initialState = instance.state !== undefined ? instance.state : null;
	instance.updater = classComponentUpdater;
	instance.props = newProps;
	instance.state = initialState; // We don't bother initializing the refs object on the server, since we're not going to resolve them anyway.
	// The internal instance will be used to manage updates that happen during this mount.

	const internalInstance = {
		queue: [],
		replace: false,
	};
	set(instance, internalInstance);
	const contextType = ctor.contextType;

	if (typeof contextType === 'object' && contextType !== null) {
		instance.context = readContext$1(contextType);
	} else {
		instance.context = maskedLegacyContext;
	}

	const getDerivedStateFromProps = ctor.getDerivedStateFromProps;

	if (typeof getDerivedStateFromProps === 'function') {
		instance.state = applyDerivedStateFromProps(
			instance,
			ctor,
			getDerivedStateFromProps,
			initialState,
			newProps,
		);
	} // In order to support react-lifecycles-compat polyfilled components,
	// Unsafe lifecycles should not be invoked for components using the new APIs.

	if (
		typeof ctor.getDerivedStateFromProps !== 'function' &&
		typeof instance.getSnapshotBeforeUpdate !== 'function' &&
		(typeof instance.UNSAFE_componentWillMount === 'function' ||
			typeof instance.componentWillMount === 'function')
	) {
		callComponentWillMount(ctor, instance); // If we had additional state updates during this life-cycle, let's
		// process them now.

		processUpdateQueue(
			internalInstance,
			instance,
			newProps,
			maskedLegacyContext,
		);
	}
}

// Ids are base 32 strings whose binary representation corresponds to the
// position of a node in a tree.
// Every time the tree forks into multiple children, we add additional bits to
// the left of the sequence that represent the position of the child within the
// current level of children.
//
//      00101       00010001011010101
//      ╰─┬─╯       ╰───────┬───────╯
//   Fork 5 of 20       Parent id
//
// The leading 0s are important. In the above example, you only need 3 bits to
// represent slot 5. However, you need 5 bits to represent all the forks at
// the current level, so we must account for the empty bits at the end.
//
// For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,
// the zeroth id at a level would be indistinguishable from its parent.
//
// If a node has only one child, and does not materialize an id (i.e. does not
// contain a useId hook), then we don't need to allocate any space in the
// sequence. It's treated as a transparent indirection. For example, these two
// trees produce the same ids:
//
// <>                          <>
//   <Indirection>               <A />
//     <A />                     <B />
//   </Indirection>            </>
//   <B />
// </>
//
// However, we cannot skip any node that materializes an id. Otherwise, a parent
// id that does not fork would be indistinguishable from its child id. For
// example, this tree does not fork, but the parent and child must have
// different ids.
//
// <Parent>
//   <Child />
// </Parent>
//
// To handle this scenario, every time we materialize an id, we allocate a
// new level with a single slot. You can think of this as a fork with only one
// prong, or an array of children with length 1.
//
// It's possible for the size of the sequence to exceed 32 bits, the max
// size for bitwise operations. When this happens, we make more room by
// converting the right part of the id to a string and storing it in an overflow
// variable. We use a base 32 string representation, because 32 is the largest
// power of 2 that is supported by toString(). We want the base to be large so
// that the resulting ids are compact, and we want the base to be a power of 2
// because every log2(base) bits corresponds to a single character, i.e. every
// log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without
// affecting the final result.
const emptyTreeContext = {
	id: 1,
	overflow: '',
};
function getTreeId(context) {
	const overflow = context.overflow;
	const idWithLeadingBit = context.id;
	const id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
	return id.toString(32) + overflow;
}
function pushTreeContext(baseContext, totalChildren, index) {
	const baseIdWithLeadingBit = baseContext.id;
	const baseOverflow = baseContext.overflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part
	// of the id; we use it to account for leading 0s.

	const baseLength = getBitLength(baseIdWithLeadingBit) - 1;
	const baseId = baseIdWithLeadingBit & ~(1 << baseLength);
	const slot = index + 1;
	const length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into
	// consideration the leading 1 we use to mark the end of the sequence.

	if (length > 30) {
		// We overflowed the bitwise-safe range. Fall back to slower algorithm.
		// This branch assumes the length of the base id is greater than 5; it won't
		// work for smaller ids, because you need 5 bits per character.
		//
		// We encode the id in multiple steps: first the base id, then the
		// remaining digits.
		//
		// Each 5 bit sequence corresponds to a single base 32 character. So for
		// example, if the current id is 23 bits long, we can convert 20 of those
		// bits into a string of 4 characters, with 3 bits left over.
		//
		// First calculate how many bits in the base id represent a complete
		// sequence of characters.
		const numberOfOverflowBits = baseLength - (baseLength % 5); // Then create a bitmask that selects only those bits.

		const newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.

		const newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.

		const restOfBaseId = baseId >> numberOfOverflowBits;
		const restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because
		// we made more room, this time it won't overflow.

		const restOfLength = getBitLength(totalChildren) + restOfBaseLength;
		const restOfNewBits = slot << restOfBaseLength;
		const id = restOfNewBits | restOfBaseId;
		const overflow = newOverflow + baseOverflow;
		return {
			id: (1 << restOfLength) | id,
			overflow,
		};
	} else {
		// Normal path
		const newBits = slot << baseLength;
		const id = newBits | baseId;
		const overflow = baseOverflow;
		return {
			id: (1 << length) | id,
			overflow,
		};
	}
}

function getBitLength(number) {
	return 32 - clz32(number);
}

function getLeadingBit(id) {
	return 1 << (getBitLength(id) - 1);
} // TODO: Math.clz32 is supported in Node 12+. Maybe we can drop the fallback.

const clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.
// Based on:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

const log = Math.log;
const LN2 = Math.LN2;

function clz32Fallback(x) {
	const asUint = x >>> 0;

	if (asUint === 0) {
		return 32;
	}

	return (31 - ((log(asUint) / LN2) | 0)) | 0;
}

// Corresponds to ReactFiberWakeable and ReactFlightWakeable modules. Generally,
// changes to one module should be reflected in the others.
// TODO: Rename this module and the corresponding Fiber one to "Thenable"
// instead of "Wakeable". Or some other more appropriate name.
// An error that is thrown (e.g. by `use`) to trigger Suspense. If we
// detect this is caught by userspace, we'll log a warning in development.
const SuspenseException = new Error(
	"Suspense Exception: This is not a real error! It's an implementation " +
		'detail of `use` to interrupt the current render. You must either ' +
		'rethrow it immediately, or move the `use` call outside of the ' +
		'`try/catch` block. Capturing without rethrowing will lead to ' +
		'unexpected behavior.\n\n' +
		'To handle async errors, wrap your component in an error boundary, or ' +
		"call the promise's `.catch` method and pass the result to `use`",
);
function createThenableState() {
	// The ThenableState is created the first time a component suspends. If it
	// suspends again, we'll reuse the same state.
	return [];
}

function noop$2() {}

function trackUsedThenable(thenableState, thenable, index) {
	const previous = thenableState[index];

	if (previous === undefined) {
		thenableState.push(thenable);
	} else {
		if (previous !== thenable) {
			// Reuse the previous thenable, and drop the new one. We can assume
			// they represent the same value, because components are idempotent.
			// Avoid an unhandled rejection errors for the Promises that we'll
			// intentionally ignore.
			thenable.then(noop$2, noop$2);
			thenable = previous;
		}
	} // We use an expando to track the status and result of a thenable so that we
	// can synchronously unwrap the value. Think of this as an extension of the
	// Promise API, or a custom interface that is a superset of Thenable.
	//
	// If the thenable doesn't have a status, set it to "pending" and attach
	// a listener that will update its status and result when it resolves.

	switch (thenable.status) {
		case 'fulfilled': {
			const fulfilledValue = thenable.value;
			return fulfilledValue;
		}

		case 'rejected': {
			const rejectedError = thenable.reason;
			throw rejectedError;
		}

		default: {
			if (typeof thenable.status === 'string');
			else {
				const pendingThenable = thenable;
				pendingThenable.status = 'pending';
				pendingThenable.then(
					(fulfilledValue) => {
						if (thenable.status === 'pending') {
							const fulfilledThenable = thenable;
							fulfilledThenable.status = 'fulfilled';
							fulfilledThenable.value = fulfilledValue;
						}
					},
					(error) => {
						if (thenable.status === 'pending') {
							const rejectedThenable = thenable;
							rejectedThenable.status = 'rejected';
							rejectedThenable.reason = error;
						}
					},
				); // Check one more time in case the thenable resolved synchronously

				switch (thenable.status) {
					case 'fulfilled': {
						const fulfilledThenable = thenable;
						return fulfilledThenable.value;
					}

					case 'rejected': {
						const rejectedThenable = thenable;
						throw rejectedThenable.reason;
					}
				}
			} // Suspend.
			//
			// Throwing here is an implementation detail that allows us to unwind the
			// call stack. But we shouldn't allow it to leak into userspace. Throw an
			// opaque placeholder value instead of the actual thenable. If it doesn't
			// get captured by the work loop, log a warning, because that means
			// something in userspace must have caught it.

			suspendedThenable = thenable;
			throw SuspenseException;
		}
	}
} // This is used to track the actual thenable that suspended so it can be
// passed to the rest of the Suspense implementation — which, for historical
// reasons, expects to receive a thenable.

let suspendedThenable = null;
function getSuspendedThenable() {
	// This is called right after `use` suspends by throwing an exception. `use`
	// throws an opaque value instead of the thenable itself so that it can't be
	// caught in userspace. Then the work loop accesses the actual thenable using
	// this function.
	if (suspendedThenable === null) {
		throw new Error(
			'Expected a suspended thenable. This is a bug in React. Please file ' +
				'an issue.',
		);
	}

	const thenable = suspendedThenable;
	suspendedThenable = null;
	return thenable;
}

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
	return (
		(x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare
	);
}

const objectIs = typeof Object.is === 'function' ? Object.is : is; // $FlowFixMe[method-unbinding]

let currentlyRenderingComponent = null;
let currentlyRenderingTask = null;
let firstWorkInProgressHook = null;
let workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook

let isReRender = false; // Whether an update was scheduled during the currently executing render pass.

let didScheduleRenderPhaseUpdate = false; // Counts the number of useId hooks in this component

let localIdCounter = 0; // Counts the number of use(thenable) calls in this component

let thenableIndexCounter = 0;
let thenableState = null; // Lazily created map of render-phase updates

let renderPhaseUpdates = null; // Counter to prevent infinite loops.

let numberOfReRenders = 0;
const RE_RENDER_LIMIT = 25;

function resolveCurrentlyRenderingComponent() {
	if (currentlyRenderingComponent === null) {
		throw new Error(
			'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +
				' one of the following reasons:\n' +
				'1. You might have mismatching versions of React and the renderer (such as React DOM)\n' +
				'2. You might be breaking the Rules of Hooks\n' +
				'3. You might have more than one copy of React in the same app\n' +
				'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',
		);
	}

	return currentlyRenderingComponent;
}

function areHookInputsEqual(nextDeps, prevDeps) {
	if (prevDeps === null) {
		return false;
	}

	for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
		// $FlowFixMe[incompatible-use] found when upgrading Flow
		if (objectIs(nextDeps[i], prevDeps[i])) {
			continue;
		}

		return false;
	}

	return true;
}

function createHook() {
	if (numberOfReRenders > 0) {
		throw new Error('Rendered more hooks than during the previous render');
	}

	return {
		memoizedState: null,
		queue: null,
		next: null,
	};
}

function createWorkInProgressHook() {
	if (workInProgressHook === null) {
		// This is the first hook in the list
		if (firstWorkInProgressHook === null) {
			isReRender = false;
			firstWorkInProgressHook = workInProgressHook = createHook();
		} else {
			// There's already a work-in-progress. Reuse it.
			isReRender = true;
			workInProgressHook = firstWorkInProgressHook;
		}
	} else {
		if (workInProgressHook.next === null) {
			isReRender = false; // Append to the end of the list

			workInProgressHook = workInProgressHook.next = createHook();
		} else {
			// There's already a work-in-progress. Reuse it.
			isReRender = true;
			workInProgressHook = workInProgressHook.next;
		}
	}

	return workInProgressHook;
}

function prepareToUseHooks(task, componentIdentity, prevThenableState) {
	currentlyRenderingComponent = componentIdentity;
	currentlyRenderingTask = task;
	// didScheduleRenderPhaseUpdate = false;
	// firstWorkInProgressHook = null;
	// numberOfReRenders = 0;
	// renderPhaseUpdates = null;
	// workInProgressHook = null;

	localIdCounter = 0;
	thenableIndexCounter = 0;
	thenableState = prevThenableState;
}
function finishHooks(Component, props, children, refOrContext) {
	// This must be called after every function component to prevent hooks from
	// being used in classes.
	while (didScheduleRenderPhaseUpdate) {
		// Updates were scheduled during the render phase. They are stored in
		// the `renderPhaseUpdates` map. Call the component again, reusing the
		// work-in-progress hooks and applying the additional updates on top. Keep
		// restarting until no more updates are scheduled.
		didScheduleRenderPhaseUpdate = false;
		localIdCounter = 0;
		thenableIndexCounter = 0;
		numberOfReRenders += 1; // Start over from the beginning of the list

		workInProgressHook = null;
		children = Component(props, refOrContext);
	}

	resetHooksState();
	return children;
}
function getThenableStateAfterSuspending() {
	const state = thenableState;
	thenableState = null;
	return state;
}
function checkDidRenderIdHook() {
	// This should be called immediately after every finishHooks call.
	// Conceptually, it's part of the return value of finishHooks; it's only a
	// separate function to avoid using an array tuple.
	const didRenderIdHook = localIdCounter !== 0;
	return didRenderIdHook;
} // Reset the internal hooks state if an error occurs while rendering a component

function resetHooksState() {
	currentlyRenderingComponent = null;
	currentlyRenderingTask = null;
	didScheduleRenderPhaseUpdate = false;
	firstWorkInProgressHook = null;
	numberOfReRenders = 0;
	renderPhaseUpdates = null;
	workInProgressHook = null;
}

function readContext(context) {
	return readContext$1(context);
}

function useContext(context) {
	resolveCurrentlyRenderingComponent();
	return readContext$1(context);
}

function basicStateReducer(state, action) {
	// $FlowFixMe[incompatible-use]: Flow doesn't like mixed types
	return typeof action === 'function' ? action(state) : action;
}

function useState(initialState) {
	return useReducer(
		basicStateReducer, // useReducer has a special case to support lazy useState initializers
		initialState,
	);
}
function useReducer(reducer, initialArg, init) {
	currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
	workInProgressHook = createWorkInProgressHook();

	if (isReRender) {
		// This is a re-render. Apply the new render phase updates to the previous
		// current hook.
		const queue = workInProgressHook.queue;
		const dispatch = queue.dispatch;

		if (renderPhaseUpdates !== null) {
			// Render phase updates are stored in a map of queue -> linked list
			const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

			if (firstRenderPhaseUpdate !== undefined) {
				// $FlowFixMe[incompatible-use] found when upgrading Flow
				renderPhaseUpdates.delete(queue); // $FlowFixMe[incompatible-use] found when upgrading Flow

				let newState = workInProgressHook.memoizedState;
				let update = firstRenderPhaseUpdate;

				do {
					// Process this render phase update. We don't have to check the
					// priority because it will always be the same as the current
					// render's.
					const action = update.action;

					newState = reducer(newState, action);

					update = update.next;
				} while (update !== null); // $FlowFixMe[incompatible-use] found when upgrading Flow

				workInProgressHook.memoizedState = newState;
				return [newState, dispatch];
			}
		} // $FlowFixMe[incompatible-use] found when upgrading Flow

		return [workInProgressHook.memoizedState, dispatch];
	} else {
		let initialState;

		if (reducer === basicStateReducer) {
			// Special case for `useState`.
			initialState =
				typeof initialArg === 'function' ? initialArg() : initialArg;
		} else {
			initialState = init !== undefined ? init(initialArg) : initialArg;
		}

		workInProgressHook.memoizedState = initialState; // $FlowFixMe[incompatible-use] found when upgrading Flow

		const queue = (workInProgressHook.queue = {
			last: null,
			dispatch: null,
		});
		const dispatch = (queue.dispatch = dispatchAction.bind(
			null,
			currentlyRenderingComponent,
			queue,
		)); // $FlowFixMe[incompatible-use] found when upgrading Flow

		return [workInProgressHook.memoizedState, dispatch];
	}
}

function useMemo(nextCreate, deps) {
	currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
	workInProgressHook = createWorkInProgressHook();
	const nextDeps = deps === undefined ? null : deps;

	if (workInProgressHook !== null) {
		const prevState = workInProgressHook.memoizedState;

		if (prevState !== null) {
			if (nextDeps !== null) {
				const prevDeps = prevState[1];

				if (areHookInputsEqual(nextDeps, prevDeps)) {
					return prevState[0];
				}
			}
		}
	}

	const nextValue = nextCreate();

	workInProgressHook.memoizedState = [nextValue, nextDeps];
	return nextValue;
}

function useRef(initialValue) {
	currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
	workInProgressHook = createWorkInProgressHook();
	const previousRef = workInProgressHook.memoizedState;

	if (previousRef === null) {
		const ref = {
			current: initialValue,
		};

		workInProgressHook.memoizedState = ref;
		return ref;
	} else {
		return previousRef;
	}
}

function dispatchAction(componentIdentity, queue, action) {
	if (numberOfReRenders >= RE_RENDER_LIMIT) {
		throw new Error(
			'Too many re-renders. React limits the number of renders to prevent ' +
				'an infinite loop.',
		);
	}

	if (componentIdentity === currentlyRenderingComponent) {
		// This is a render phase update. Stash it in a lazily-created map of
		// queue -> linked list of updates. After this render pass, we'll restart
		// and apply the stashed updates on top of the work-in-progress hook.
		didScheduleRenderPhaseUpdate = true;
		const update = {
			action,
			next: null,
		};

		if (renderPhaseUpdates === null) {
			renderPhaseUpdates = new Map();
		}

		const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

		if (firstRenderPhaseUpdate === undefined) {
			// $FlowFixMe[incompatible-use] found when upgrading Flow
			renderPhaseUpdates.set(queue, update);
		} else {
			// Append the update to the end of the list.
			let lastRenderPhaseUpdate = firstRenderPhaseUpdate;

			while (lastRenderPhaseUpdate.next !== null) {
				lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
			}

			lastRenderPhaseUpdate.next = update;
		}
	}
}

function useCallback(callback, deps) {
	return useMemo(() => callback, deps);
}

function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
	if (getServerSnapshot === undefined) {
		throw new Error(
			'Missing getServerSnapshot, which is required for ' +
				'server-rendered content. Will revert to client rendering.',
		);
	}

	return getServerSnapshot();
}

function useDeferredValue(value) {
	resolveCurrentlyRenderingComponent();
	return value;
}

function unsupportedStartTransition() {
	throw new Error('startTransition cannot be called during server rendering.');
}

function useTransition() {
	resolveCurrentlyRenderingComponent();
	return [false, unsupportedStartTransition];
}

function useId() {
	const task = currentlyRenderingTask;
	const treeId = getTreeId(task.treeContext);
	const responseState = currentResponseState;

	if (responseState === null) {
		throw new Error(
			'Invalid hook call. Hooks can only be called inside of the body of a function component.',
		);
	}

	const localId = localIdCounter++;
	return makeId(responseState, treeId, localId);
}

function use(usable) {
	if (usable !== null && typeof usable === 'object') {
		// $FlowFixMe[method-unbinding]
		if (typeof usable.then === 'function') {
			// This is a thenable.
			const thenable = usable;
			return unwrapThenable(thenable);
		} else if (
			usable.$$typeof === REACT_CONTEXT_TYPE ||
			usable.$$typeof === REACT_SERVER_CONTEXT_TYPE
		) {
			const context = usable;
			return readContext(context);
		}
	} // eslint-disable-next-line react-internal/safe-string-coercion

	throw new Error('An unsupported type was passed to use(): ' + String(usable));
}

function unwrapThenable(thenable) {
	const index = thenableIndexCounter;
	thenableIndexCounter += 1;

	if (thenableState === null) {
		thenableState = createThenableState();
	}

	return trackUsedThenable(thenableState, thenable, index);
}

function unsupportedRefresh() {
	throw new Error('Cache cannot be refreshed during server rendering.');
}

function useCacheRefresh() {
	return unsupportedRefresh;
}

function noop$1() {}

const HooksDispatcher = {
	readContext,
	use,
	useContext,
	useMemo,
	useReducer,
	useRef,
	useState,
	useInsertionEffect: noop$1,
	useLayoutEffect: noop$1,
	useCallback,
	// useImperativeHandle is not run in the server environment
	useImperativeHandle: noop$1,
	// Effects are not run in the server environment.
	useEffect: noop$1,
	// Debugging effect
	useDebugValue: noop$1,
	useDeferredValue,
	useTransition,
	useId,
	// Subscriptions are not setup in a server environment.
	useSyncExternalStore,
};

{
	HooksDispatcher.useCacheRefresh = useCacheRefresh;
}

let currentResponseState = null;
function setCurrentResponseState(responseState) {
	currentResponseState = responseState;
}

function getCacheSignal() {
	throw new Error('Not implemented.');
}

function getCacheForType(resourceType) {
	throw new Error('Not implemented.');
}

const DefaultCacheDispatcher = {
	getCacheSignal,
	getCacheForType,
};

const ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
const ReactCurrentCache = ReactSharedInternals.ReactCurrentCache;
const PENDING = 0;
const COMPLETED = 1;
const FLUSHED = 2;
const ABORTED = 3;
const ERRORED = 4;
const OPEN = 0;
const CLOSING = 1;
const CLOSED = 2; // This is a default heuristic for how to split up the HTML content into progressive
// loading. Our goal is to be able to display additional new content about every 500ms.
// Faster than that is unnecessary and should be throttled on the client. It also
// adds unnecessary overhead to do more splits. We don't know if it's a higher or lower
// end device but higher end suffer less from the overhead than lower end does from
// not getting small enough pieces. We error on the side of low end.
// We base this on low end 3G speeds which is about 500kbits per second. We assume
// that there can be a reasonable drop off from max bandwidth which leaves you with
// as little as 80%. We can receive half of that each 500ms - at best. In practice,
// a little bandwidth is lost to processing and contention - e.g. CSS and images that
// are downloaded along with the main content. So we estimate about half of that to be
// the lower end throughput. In other words, we expect that you can at least show
// about 12.5kb of content per 500ms. Not counting starting latency for the first
// paint.
// 500 * 1024 / 8 * .8 * 0.5 / 2

const DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;

function defaultErrorHandler(error) {
	console['error'](error); // Don't transform to our wrapper

	return null;
}

function noop() {}

function createRequest(
	children,
	resources,
	responseState,
	rootFormatContext,
	progressiveChunkSize,
	onError,
	onAllReady,
	onShellReady,
	onShellError,
	onFatalError,
) {
	prepareHostDispatcher();
	const pingedTasks = [];
	const abortSet = new Set();
	const request = {
		destination: null,
		flushScheduled: false,
		responseState,
		progressiveChunkSize:
			progressiveChunkSize === undefined
				? DEFAULT_PROGRESSIVE_CHUNK_SIZE
				: progressiveChunkSize,
		status: OPEN,
		fatalError: null,
		nextSegmentId: 0,
		allPendingTasks: 0,
		pendingRootTasks: 0,
		resources,
		completedRootSegment: null,
		abortableTasks: abortSet,
		pingedTasks: pingedTasks,
		clientRenderedBoundaries: [],
		completedBoundaries: [],
		partialBoundaries: [],
		onError: onError === undefined ? defaultErrorHandler : onError,
		onAllReady: onAllReady === undefined ? noop : onAllReady,
		onShellReady: onShellReady === undefined ? noop : onShellReady,
		onShellError: onShellError === undefined ? noop : onShellError,
		onFatalError: onFatalError === undefined ? noop : onFatalError,
	}; // This segment represents the root fallback.

	const rootSegment = createPendingSegment(
		request,
		0,
		null,
		rootFormatContext, // Root segments are never embedded in Text on either edge
		false,
		false,
	); // There is no parent so conceptually, we're unblocked to flush this segment.

	rootSegment.parentFlushed = true;
	const rootTask = createTask(
		request,
		null,
		children,
		null,
		rootSegment,
		abortSet,
		emptyContextObject,
		rootContextSnapshot,
		emptyTreeContext,
	);
	pingedTasks.push(rootTask);
	return request;
}
let currentRequest = null;
function resolveRequest() {
	if (currentRequest) return currentRequest;

	if (supportsRequestStorage) {
		const store = requestStorage.getStore();
		if (store) return store;
	}

	return null;
}

function pingTask(request, task) {
	const pingedTasks = request.pingedTasks;
	pingedTasks.push(task);

	if (request.pingedTasks.length === 1) {
		request.flushScheduled = request.destination !== null;
		scheduleWork(() => performWork(request));
	}
}

function createSuspenseBoundary(request, fallbackAbortableTasks) {
	return {
		id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
		rootSegmentID: -1,
		parentFlushed: false,
		pendingTasks: 0,
		forceClientRender: false,
		completedSegments: [],
		byteSize: 0,
		fallbackAbortableTasks,
		errorDigest: null,
		resources: createBoundaryResources(),
	};
}

function createTask(
	request,
	thenableState,
	node,
	blockedBoundary,
	blockedSegment,
	abortSet,
	legacyContext,
	context,
	treeContext,
) {
	request.allPendingTasks++;

	if (blockedBoundary === null) {
		request.pendingRootTasks++;
	} else {
		blockedBoundary.pendingTasks++;
	}

	const task = {
		node,
		ping: () => pingTask(request, task),
		blockedBoundary,
		blockedSegment,
		abortSet,
		legacyContext,
		context,
		treeContext,
		thenableState,
	};

	abortSet.add(task);
	return task;
}

function createPendingSegment(
	request,
	index,
	boundary,
	formatContext,
	lastPushedText,
	textEmbedded,
) {
	return {
		status: PENDING,
		id: -1,
		// lazily assigned later
		index,
		parentFlushed: false,
		chunks: [],
		children: [],
		formatContext,
		boundary,
		lastPushedText,
		textEmbedded,
	};
} // DEV-only global reference to the currently executing task

function popComponentStackInDEV(task) {} // stash the component stack of an unwinding error until it is processed

function logRecoverableError(request, error) {
	// If this callback errors, we intentionally let that error bubble up to become a fatal error
	// so that someone fixes the error reporting instead of hiding it.
	const errorDigest = request.onError(error);

	if (errorDigest != null && typeof errorDigest !== 'string') {
		// eslint-disable-next-line react-internal/prod-error-codes
		throw new Error(
			'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
				typeof errorDigest +
				'" instead',
		);
	}

	return errorDigest;
}

function fatalError(request, error) {
	// This is called outside error handling code such as if the root errors outside
	// a suspense boundary or if the root suspense boundary's fallback errors.
	// It's also called if React itself or its host configs errors.
	const onShellError = request.onShellError;
	onShellError(error);
	const onFatalError = request.onFatalError;
	onFatalError(error);

	if (request.destination !== null) {
		request.status = CLOSED;
		closeWithError(request.destination, error);
	} else {
		request.status = CLOSING;
		request.fatalError = error;
	}
}

function renderSuspenseBoundary(request, task, props) {
	const parentBoundary = task.blockedBoundary;
	const parentSegment = task.blockedSegment; // Each time we enter a suspense boundary, we split out into a new segment for
	// the fallback so that we can later replace that segment with the content.
	// This also lets us split out the main content even if it doesn't suspend,
	// in case it ends up generating a large subtree of content.

	const fallback = props.fallback;
	const content = props.children;
	const fallbackAbortSet = new Set();
	const newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
	const insertionIndex = parentSegment.chunks.length; // The children of the boundary segment is actually the fallback.

	const boundarySegment = createPendingSegment(
		request,
		insertionIndex,
		newBoundary,
		parentSegment.formatContext, // boundaries never require text embedding at their edges because comment nodes bound them
		false,
		false,
	);
	parentSegment.children.push(boundarySegment); // The parentSegment has a child Segment at this index so we reset the lastPushedText marker on the parent

	parentSegment.lastPushedText = false; // This segment is the actual child content. We can start rendering that immediately.

	const contentRootSegment = createPendingSegment(
		request,
		0,
		null,
		parentSegment.formatContext, // boundaries never require text embedding at their edges because comment nodes bound them
		false,
		false,
	); // We mark the root segment as having its parent flushed. It's not really flushed but there is
	// no parent segment so there's nothing to wait on.

	contentRootSegment.parentFlushed = true; // Currently this is running synchronously. We could instead schedule this to pingedTasks.
	// I suspect that there might be some efficiency benefits from not creating the suspended task
	// and instead just using the stack if possible.
	// TODO: Call this directly instead of messing with saving and restoring contexts.
	// We can reuse the current context and task to render the content immediately without
	// context switching. We just need to temporarily switch which boundary and which segment
	// we're writing to. If something suspends, it'll spawn new suspended task with that context.

	task.blockedBoundary = newBoundary;
	task.blockedSegment = contentRootSegment;

	{
		setCurrentlyRenderingBoundaryResourcesTarget(
			request.resources,
			newBoundary.resources,
		);
	}

	try {
		// We use the safe form because we don't handle suspending here. Only error handling.
		renderNode(request, task, content);
		pushSegmentFinale(
			contentRootSegment.chunks,
			request.responseState,
			contentRootSegment.lastPushedText,
			contentRootSegment.textEmbedded,
		);
		contentRootSegment.status = COMPLETED;
		queueCompletedSegment(newBoundary, contentRootSegment);

		if (newBoundary.pendingTasks === 0) {
			// This must have been the last segment we were waiting on. This boundary is now complete.
			// Therefore we won't need the fallback. We early return so that we don't have to create
			// the fallback.
			popComponentStackInDEV(task);
			return;
		}
	} catch (error) {
		contentRootSegment.status = ERRORED;
		newBoundary.forceClientRender = true;
		newBoundary.errorDigest = logRecoverableError(request, error);
		// We don't need to schedule any task because we know the parent has written yet.
		// We do need to fallthrough to create the fallback though.
	} finally {
		{
			setCurrentlyRenderingBoundaryResourcesTarget(
				request.resources,
				parentBoundary ? parentBoundary.resources : null,
			);
		}

		task.blockedBoundary = parentBoundary;
		task.blockedSegment = parentSegment;
	} // We create suspended task for the fallback because we don't want to actually work
	// on it yet in case we finish the main content, so we queue for later.

	const suspendedFallbackTask = createTask(
		request,
		null,
		fallback,
		parentBoundary,
		boundarySegment,
		fallbackAbortSet,
		task.legacyContext,
		task.context,
		task.treeContext,
	);
	// on preparing fallbacks if we don't have any more main content to task on.

	request.pingedTasks.push(suspendedFallbackTask);
}

function renderHostElement(request, task, type, props) {
	const segment = task.blockedSegment;
	const children = pushStartInstance(
		segment.chunks,
		type,
		props,
		request.resources,
		request.responseState,
		segment.formatContext,
		segment.lastPushedText,
	);
	segment.lastPushedText = false;
	const prevContext = segment.formatContext;
	segment.formatContext = getChildFormatContext(prevContext, type, props); // We use the non-destructive form because if something suspends, we still
	// need to pop back up and finish this subtree of HTML.

	renderNode(request, task, children); // We expect that errors will fatal the whole task and that we don't need
	// the correct context. Therefore this is not in a finally.

	segment.formatContext = prevContext;
	pushEndInstance(
		segment.chunks,
		type,
		props,
		request.responseState,
		prevContext,
	);
	segment.lastPushedText = false;
}

function shouldConstruct(Component) {
	return Component.prototype && Component.prototype.isReactComponent;
}

function renderWithHooks(
	request,
	task,
	prevThenableState,
	Component,
	props,
	secondArg,
) {
	const componentIdentity = {};
	prepareToUseHooks(task, componentIdentity, prevThenableState);
	const result = Component(props, secondArg);
	return finishHooks(Component, props, result, secondArg);
}

function finishClassComponent(request, task, instance, Component, props) {
	const nextChildren = instance.render();

	{
		const childContextTypes = Component.childContextTypes;

		if (childContextTypes !== null && childContextTypes !== undefined) {
			const previousContext = task.legacyContext;
			const mergedContext = processChildContext(
				instance,
				Component,
				previousContext,
				childContextTypes,
			);
			task.legacyContext = mergedContext;
			renderNodeDestructive(request, task, null, nextChildren);
			task.legacyContext = previousContext;
			return;
		}
	}

	renderNodeDestructive(request, task, null, nextChildren);
}

function renderClassComponent(request, task, Component, props) {
	const maskedContext = getMaskedContext(Component, task.legacyContext);
	const instance = constructClassInstance(Component, props, maskedContext);
	mountClassInstance(instance, Component, props, maskedContext);
	finishClassComponent(request, task, instance, Component);
}
// components for some reason.

function renderIndeterminateComponent(
	request,
	task,
	prevThenableState,
	Component,
	props,
) {
	let legacyContext;

	{
		legacyContext = getMaskedContext(Component, task.legacyContext);
	}

	const value = renderWithHooks(
		request,
		task,
		prevThenableState,
		Component,
		props,
		legacyContext,
	);
	const hasId = checkDidRenderIdHook();

	if (
		// Run these checks in production only if the flag is off.
		// Eventually we'll delete this branch altogether.
		typeof value === 'object' &&
		value !== null &&
		typeof value.render === 'function' &&
		value.$$typeof === undefined
	) {
		mountClassInstance(value, Component, props, legacyContext);
		finishClassComponent(request, task, value, Component);
	} else {
		// the previous task every again, so we can use the destructive recursive form.

		if (hasId) {
			// This component materialized an id. We treat this as its own level, with
			// a single "child" slot.
			const prevTreeContext = task.treeContext;
			const totalChildren = 1;
			const index = 0;
			task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);

			try {
				renderNodeDestructive(request, task, null, value);
			} finally {
				task.treeContext = prevTreeContext;
			}
		} else {
			renderNodeDestructive(request, task, null, value);
		}
	}
}

function resolveDefaultProps(Component, baseProps) {
	if (Component && Component.defaultProps) {
		// Resolve default props. Taken from ReactElement
		const props = assign({}, baseProps);
		const defaultProps = Component.defaultProps;

		for (const propName in defaultProps) {
			if (props[propName] === undefined) {
				props[propName] = defaultProps[propName];
			}
		}

		return props;
	}

	return baseProps;
}

function renderForwardRef(request, task, prevThenableState, type, props, ref) {
	const children = renderWithHooks(
		request,
		task,
		prevThenableState,
		type.render,
		props,
		ref,
	);
	const hasId = checkDidRenderIdHook();

	if (hasId) {
		// This component materialized an id. We treat this as its own level, with
		// a single "child" slot.
		const prevTreeContext = task.treeContext;
		const totalChildren = 1;
		const index = 0;
		task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);

		try {
			renderNodeDestructive(request, task, null, children);
		} finally {
			task.treeContext = prevTreeContext;
		}
	} else {
		renderNodeDestructive(request, task, null, children);
	}
}

function renderMemo(request, task, prevThenableState, type, props, ref) {
	const innerType = type.type;
	const resolvedProps = resolveDefaultProps(innerType, props);
	renderElement(
		request,
		task,
		prevThenableState,
		innerType,
		resolvedProps,
		ref,
	);
}

function renderContextConsumer(request, task, context, props) {
	const render = props.children;

	const newValue = readContext$1(context);
	const newChildren = render(newValue);
	renderNodeDestructive(request, task, null, newChildren);
}

function renderContextProvider(request, task, type, props) {
	const context = type._context;
	const value = props.value;
	const children = props.children;

	task.context = pushProvider(context, value);
	renderNodeDestructive(request, task, null, children);
	task.context = popProvider();
}

function renderLazyComponent(
	request,
	task,
	prevThenableState,
	lazyComponent,
	props,
	ref,
) {
	const payload = lazyComponent._payload;
	const init = lazyComponent._init;
	const Component = init(payload);
	const resolvedProps = resolveDefaultProps(Component, props);
	renderElement(
		request,
		task,
		prevThenableState,
		Component,
		resolvedProps,
		ref,
	);
}

function renderOffscreen(request, task, props) {
	const mode = props.mode;

	if (mode === 'hidden');
	else {
		// A visible Offscreen boundary is treated exactly like a fragment: a
		// pure indirection.
		renderNodeDestructive(request, task, null, props.children);
	}
}

function renderElement(request, task, prevThenableState, type, props, ref) {
	if (typeof type === 'function') {
		if (shouldConstruct(type)) {
			renderClassComponent(request, task, type, props);
			return;
		} else {
			renderIndeterminateComponent(
				request,
				task,
				prevThenableState,
				type,
				props,
			);
			return;
		}
	}

	if (typeof type === 'string') {
		renderHostElement(request, task, type, props);
		return;
	}

	switch (type) {
		// LegacyHidden acts the same as a fragment. This only works because we
		// currently assume that every instance of LegacyHidden is accompanied by a
		// host component wrapper. In the hidden mode, the host component is given a
		// `hidden` attribute, which ensures that the initial HTML is not visible.
		// To support the use of LegacyHidden as a true fragment, without an extra
		// DOM node, we would have to hide the initial HTML in some other way.
		// TODO: Delete in LegacyHidden. It's an unstable API only used in the
		// www build. As a migration step, we could add a special prop to Offscreen
		// that simulates the old behavior (no hiding, no change to effects).
		case REACT_LEGACY_HIDDEN_TYPE:
		case REACT_DEBUG_TRACING_MODE_TYPE:
		case REACT_STRICT_MODE_TYPE:
		case REACT_PROFILER_TYPE:
		case REACT_FRAGMENT_TYPE: {
			renderNodeDestructive(request, task, null, props.children);
			return;
		}

		case REACT_OFFSCREEN_TYPE: {
			renderOffscreen(request, task, props);
			return;
		}

		case REACT_SUSPENSE_LIST_TYPE: {
			renderNodeDestructive(request, task, null, props.children);
			return;
		}

		case REACT_SCOPE_TYPE: {
			throw new Error('ReactDOMServer does not yet support scope components.');
		}

		case REACT_SUSPENSE_TYPE: {
			{
				renderSuspenseBoundary(request, task, props);
			}

			return;
		}
	}

	if (typeof type === 'object' && type !== null) {
		switch (type.$$typeof) {
			case REACT_FORWARD_REF_TYPE: {
				renderForwardRef(request, task, prevThenableState, type, props, ref);
				return;
			}

			case REACT_MEMO_TYPE: {
				renderMemo(request, task, prevThenableState, type, props, ref);
				return;
			}

			case REACT_PROVIDER_TYPE: {
				renderContextProvider(request, task, type, props);
				return;
			}

			case REACT_CONTEXT_TYPE: {
				renderContextConsumer(request, task, type, props);
				return;
			}

			case REACT_LAZY_TYPE: {
				renderLazyComponent(request, task, prevThenableState, type, props);
				return;
			}
		}
	}

	let info = '';

	throw new Error(
		'Element type is invalid: expected a string (for built-in ' +
			'components) or a class/function (for composite components) ' +
			('but got: ' + (type == null ? type : typeof type) + '.' + info),
	);
} // $FlowFixMe[missing-local-annot]

function renderNodeDestructive(
	request,
	task, // The thenable state reused from the previous attempt, if any. This is almost
	// always null, except when called by retryTask.
	prevThenableState,
	node,
) {
	{
		return renderNodeDestructiveImpl(request, task, prevThenableState, node);
	}
} // This function by it self renders a node and consumes the task by mutating it
// to update the current execution state.

function renderNodeDestructiveImpl(request, task, prevThenableState, node) {
	// Stash the node we're working on. We'll pick up from this task in case
	// something suspends.
	task.node = node; // Handle object types

	if (typeof node === 'object' && node !== null) {
		switch (node.$$typeof) {
			case REACT_ELEMENT_TYPE: {
				const element = node;
				const type = element.type;
				const props = element.props;
				const ref = element.ref;
				renderElement(request, task, prevThenableState, type, props, ref);
				return;
			}

			case REACT_PORTAL_TYPE:
				throw new Error(
					'Portals are not currently supported by the server renderer. ' +
						'Render them conditionally so that they only appear on the client render.',
				);

			case REACT_LAZY_TYPE: {
				const lazyNode = node;
				const payload = lazyNode._payload;
				const init = lazyNode._init;
				let resolvedNode;

				{
					resolvedNode = init(payload);
				}

				renderNodeDestructive(request, task, null, resolvedNode);
				return;
			}
		}

		if (isArray(node)) {
			renderChildrenArray(request, task, node);
			return;
		}

		const iteratorFn = getIteratorFn(node);

		if (iteratorFn) {
			const iterator = iteratorFn.call(node);

			if (iterator) {
				// We need to know how many total children are in this set, so that we
				// can allocate enough id slots to acommodate them. So we must exhaust
				// the iterator before we start recursively rendering the children.
				// TODO: This is not great but I think it's inherent to the id
				// generation algorithm.
				let step = iterator.next(); // If there are not entries, we need to push an empty so we start by checking that.

				if (!step.done) {
					const children = [];

					do {
						children.push(step.value);
						step = iterator.next();
					} while (!step.done);

					renderChildrenArray(request, task, children);
					return;
				}

				return;
			}
		} // Usables are a valid React node type. When React encounters a Usable in
		// a child position, it unwraps it using the same algorithm as `use`. For
		// example, for promises, React will throw an exception to unwind the
		// stack, then replay the component once the promise resolves.
		//
		// A difference from `use` is that React will keep unwrapping the value
		// until it reaches a non-Usable type.
		//
		// e.g. Usable<Usable<Usable<T>>> should resolve to T

		const maybeUsable = node;

		if (typeof maybeUsable.then === 'function') {
			const thenable = maybeUsable;
			return renderNodeDestructiveImpl(
				request,
				task,
				null,
				unwrapThenable(thenable),
			);
		}

		if (
			maybeUsable.$$typeof === REACT_CONTEXT_TYPE ||
			maybeUsable.$$typeof === REACT_SERVER_CONTEXT_TYPE
		) {
			const context = maybeUsable;
			return renderNodeDestructiveImpl(
				request,
				task,
				null,
				readContext$1(context),
			);
		} // $FlowFixMe[method-unbinding]

		const childString = Object.prototype.toString.call(node);
		throw new Error(
			'Objects are not valid as a React child (found: ' +
				(childString === '[object Object]'
					? 'object with keys {' + Object.keys(node).join(', ') + '}'
					: childString) +
				'). ' +
				'If you meant to render a collection of children, use an array ' +
				'instead.',
		);
	}

	if (typeof node === 'string') {
		const segment = task.blockedSegment;
		segment.lastPushedText = pushTextInstance(
			task.blockedSegment.chunks,
			node,
			request.responseState,
			segment.lastPushedText,
		);
		return;
	}

	if (typeof node === 'number') {
		const segment = task.blockedSegment;
		segment.lastPushedText = pushTextInstance(
			task.blockedSegment.chunks,
			'' + node,
			request.responseState,
			segment.lastPushedText,
		);
		return;
	}
}

function renderChildrenArray(request, task, children) {
	const totalChildren = children.length;

	for (let i = 0; i < totalChildren; i++) {
		const prevTreeContext = task.treeContext;
		task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);

		try {
			// We need to use the non-destructive form so that we can safely pop back
			// up and render the sibling if something suspends.
			renderNode(request, task, children[i]);
		} finally {
			task.treeContext = prevTreeContext;
		}
	}
}

function spawnNewSuspendedTask(request, task, thenableState, x) {
	// Something suspended, we'll need to create a new segment and resolve it later.
	const segment = task.blockedSegment;
	const insertionIndex = segment.chunks.length;
	const newSegment = createPendingSegment(
		request,
		insertionIndex,
		null,
		segment.formatContext, // Adopt the parent segment's leading text embed
		segment.lastPushedText, // Assume we are text embedded at the trailing edge
		true,
	);
	segment.children.push(newSegment); // Reset lastPushedText for current Segment since the new Segment "consumed" it

	segment.lastPushedText = false;
	const newTask = createTask(
		request,
		thenableState,
		task.node,
		task.blockedBoundary,
		newSegment,
		task.abortSet,
		task.legacyContext,
		task.context,
		task.treeContext,
	);

	const ping = newTask.ping;
	x.then(ping, ping);
} // This is a non-destructive form of rendering a node. If it suspends it spawns
// a new task and restores the context of this task to what it was before.

function renderNode(request, task, node) {
	// Store how much we've pushed at this point so we can reset it in case something
	// suspended partially through writing something.
	const segment = task.blockedSegment;
	const childrenLength = segment.children.length;
	const chunkLength = segment.chunks.length; // Snapshot the current context in case something throws to interrupt the
	// process.

	const previousFormatContext = task.blockedSegment.formatContext;
	const previousLegacyContext = task.legacyContext;
	const previousContext = task.context;

	try {
		return renderNodeDestructive(request, task, null, node);
	} catch (thrownValue) {
		resetHooksState(); // Reset the write pointers to where we started.

		segment.children.length = childrenLength;
		segment.chunks.length = chunkLength;
		const x =
			thrownValue === SuspenseException // This is a special type of exception used for Suspense. For historical
				? // reasons, the rest of the Suspense implementation expects the thrown
					// value to be a thenable, because before `use` existed that was the
					// (unstable) API for suspending. This implementation detail can change
					// later, once we deprecate the old API in favor of `use`.
					getSuspendedThenable()
				: thrownValue; // $FlowFixMe[method-unbinding]

		if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
			const wakeable = x;
			const thenableState = getThenableStateAfterSuspending();
			spawnNewSuspendedTask(request, task, thenableState, wakeable); // Restore the context. We assume that this will be restored by the inner
			// functions in case nothing throws so we don't use "finally" here.

			task.blockedSegment.formatContext = previousFormatContext;
			task.legacyContext = previousLegacyContext;
			task.context = previousContext; // Restore all active ReactContexts to what they were before.

			switchContext(previousContext);

			return;
		} else {
			// Restore the context. We assume that this will be restored by the inner
			// functions in case nothing throws so we don't use "finally" here.
			task.blockedSegment.formatContext = previousFormatContext;
			task.legacyContext = previousLegacyContext;
			task.context = previousContext; // Restore all active ReactContexts to what they were before.

			switchContext(previousContext);
			// Let's terminate the rest of the tree and don't render any siblings.

			throw x;
		}
	}
}

function erroredTask(request, boundary, segment, error) {
	// Report the error to a global handler.
	const errorDigest = logRecoverableError(request, error);

	if (boundary === null) {
		fatalError(request, error);
	} else {
		boundary.pendingTasks--;

		if (!boundary.forceClientRender) {
			boundary.forceClientRender = true;
			boundary.errorDigest = errorDigest;
			// so we can flush it, if the parent already flushed.

			if (boundary.parentFlushed) {
				// We don't have a preference where in the queue this goes since it's likely
				// to error on the client anyway. However, intentionally client-rendered
				// boundaries should be flushed earlier so that they can start on the client.
				// We reuse the same queue for errors.
				request.clientRenderedBoundaries.push(boundary);
			}
		}
	}

	request.allPendingTasks--;

	if (request.allPendingTasks === 0) {
		const onAllReady = request.onAllReady;
		onAllReady();
	}
}

function abortTaskSoft(task) {
	// This aborts task without aborting the parent boundary that it blocks.
	// It's used for when we didn't need this task to complete the tree.
	// If task was needed, then it should use abortTask instead.
	const request = this;
	const boundary = task.blockedBoundary;
	const segment = task.blockedSegment;
	segment.status = ABORTED;
	finishedTask(request, boundary, segment);
}

function abortTask(task, request, error) {
	// This aborts the task and aborts the parent that it blocks, putting it into
	// client rendered mode.
	const boundary = task.blockedBoundary;
	const segment = task.blockedSegment;
	segment.status = ABORTED;

	if (boundary === null) {
		request.allPendingTasks--; // We didn't complete the root so we have nothing to show. We can close
		// the request;

		if (request.status !== CLOSING && request.status !== CLOSED) {
			logRecoverableError(request, error);
			fatalError(request, error);
		}
	} else {
		boundary.pendingTasks--;

		if (!boundary.forceClientRender) {
			boundary.forceClientRender = true;
			boundary.errorDigest = request.onError(error);

			if (boundary.parentFlushed) {
				request.clientRenderedBoundaries.push(boundary);
			}
		} // If this boundary was still pending then we haven't already cancelled its fallbacks.
		// We'll need to abort the fallbacks, which will also error that parent boundary.

		boundary.fallbackAbortableTasks.forEach((fallbackTask) =>
			abortTask(fallbackTask, request, error),
		);
		boundary.fallbackAbortableTasks.clear();
		request.allPendingTasks--;

		if (request.allPendingTasks === 0) {
			const onAllReady = request.onAllReady;
			onAllReady();
		}
	}
}

function queueCompletedSegment(boundary, segment) {
	if (
		segment.chunks.length === 0 &&
		segment.children.length === 1 &&
		segment.children[0].boundary === null
	) {
		// This is an empty segment. There's nothing to write, so we can instead transfer the ID
		// to the child. That way any existing references point to the child.
		const childSegment = segment.children[0];
		childSegment.id = segment.id;
		childSegment.parentFlushed = true;

		if (childSegment.status === COMPLETED) {
			queueCompletedSegment(boundary, childSegment);
		}
	} else {
		const completedSegments = boundary.completedSegments;
		completedSegments.push(segment);
	}
}

function finishedTask(request, boundary, segment) {
	if (boundary === null) {
		if (segment.parentFlushed) {
			if (request.completedRootSegment !== null) {
				throw new Error(
					'There can only be one root segment. This is a bug in React.',
				);
			}

			request.completedRootSegment = segment;
		}

		request.pendingRootTasks--;

		if (request.pendingRootTasks === 0) {
			// We have completed the shell so the shell can't error anymore.
			request.onShellError = noop;
			const onShellReady = request.onShellReady;
			onShellReady();
		}
	} else {
		boundary.pendingTasks--;

		if (boundary.forceClientRender);
		else if (boundary.pendingTasks === 0) {
			// This must have been the last segment we were waiting on. This boundary is now complete.
			if (segment.parentFlushed) {
				// Our parent segment already flushed, so we need to schedule this segment to be emitted.
				// If it is a segment that was aborted, we'll write other content instead so we don't need
				// to emit it.
				if (segment.status === COMPLETED) {
					queueCompletedSegment(boundary, segment);
				}
			}

			if (boundary.parentFlushed) {
				// The segment might be part of a segment that didn't flush yet, but if the boundary's
				// parent flushed, we need to schedule the boundary to be emitted.
				request.completedBoundaries.push(boundary);
			} // We can now cancel any pending task on the fallback since we won't need to show it anymore.
			// This needs to happen after we read the parentFlushed flags because aborting can finish
			// work which can trigger user code, which can start flushing, which can change those flags.

			boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
			boundary.fallbackAbortableTasks.clear();
		} else {
			if (segment.parentFlushed) {
				// Our parent already flushed, so we need to schedule this segment to be emitted.
				// If it is a segment that was aborted, we'll write other content instead so we don't need
				// to emit it.
				if (segment.status === COMPLETED) {
					queueCompletedSegment(boundary, segment);
					const completedSegments = boundary.completedSegments;

					if (completedSegments.length === 1) {
						// This is the first time since we last flushed that we completed anything.
						// We can schedule this boundary to emit its partially completed segments early
						// in case the parent has already been flushed.
						if (boundary.parentFlushed) {
							request.partialBoundaries.push(boundary);
						}
					}
				}
			}
		}
	}

	request.allPendingTasks--;

	if (request.allPendingTasks === 0) {
		// This needs to be called at the very end so that we can synchronously write the result
		// in the callback if needed.
		const onAllReady = request.onAllReady;
		onAllReady();
	}
}

function retryTask(request, task) {
	{
		const blockedBoundary = task.blockedBoundary;
		setCurrentlyRenderingBoundaryResourcesTarget(
			request.resources,
			blockedBoundary ? blockedBoundary.resources : null,
		);
	}

	const segment = task.blockedSegment;

	if (segment.status !== PENDING) {
		// We completed this by other means before we had a chance to retry it.
		return;
	} // We restore the context to what it was when we suspended.
	// We don't restore it after we leave because it's likely that we'll end up
	// needing a very similar context soon again.

	switchContext(task.context);

	const childrenLength = segment.children.length;
	const chunkLength = segment.chunks.length;

	try {
		// We call the destructive form that mutates this task. That way if something
		// suspends again, we can reuse the same task instead of spawning a new one.
		// Reset the task's thenable state before continuing, so that if a later
		// component suspends we can reuse the same task object. If the same
		// component suspends again, the thenable state will be restored.
		const prevThenableState = task.thenableState;
		task.thenableState = null;
		renderNodeDestructive(request, task, prevThenableState, task.node);
		pushSegmentFinale(
			segment.chunks,
			request.responseState,
			segment.lastPushedText,
			segment.textEmbedded,
		);
		task.abortSet.delete(task);
		segment.status = COMPLETED;
		finishedTask(request, task.blockedBoundary, segment);
	} catch (thrownValue) {
		resetHooksState(); // Reset the write pointers to where we started.

		segment.children.length = childrenLength;
		segment.chunks.length = chunkLength;
		const x =
			thrownValue === SuspenseException // This is a special type of exception used for Suspense. For historical
				? // reasons, the rest of the Suspense implementation expects the thrown
					// value to be a thenable, because before `use` existed that was the
					// (unstable) API for suspending. This implementation detail can change
					// later, once we deprecate the old API in favor of `use`.
					getSuspendedThenable()
				: thrownValue; // $FlowFixMe[method-unbinding]

		if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
			// Something suspended again, let's pick it back up later.
			const ping = task.ping;
			x.then(ping, ping);
			task.thenableState = getThenableStateAfterSuspending();
		} else {
			task.abortSet.delete(task);
			segment.status = ERRORED;
			erroredTask(request, task.blockedBoundary, segment, x);
		}
	} finally {
		{
			setCurrentlyRenderingBoundaryResourcesTarget(request.resources, null);
		}
	}
}

function performWork(request) {
	if (request.status === CLOSED) {
		return;
	}

	const prevContext = getActiveContext();
	const prevDispatcher = ReactCurrentDispatcher.current;
	ReactCurrentDispatcher.current = HooksDispatcher;
	let prevCacheDispatcher;

	{
		prevCacheDispatcher = ReactCurrentCache.current;
		ReactCurrentCache.current = DefaultCacheDispatcher;
	}

	const prevRequest = currentRequest;
	currentRequest = request;

	const prevResponseState = currentResponseState;
	setCurrentResponseState(request.responseState);

	try {
		const pingedTasks = request.pingedTasks;
		let i;

		for (i = 0; i < pingedTasks.length; i++) {
			const task = pingedTasks[i];
			retryTask(request, task);
		}

		pingedTasks.splice(0, i);

		if (request.destination !== null) {
			flushCompletedQueues(request, request.destination);
		}
	} catch (error) {
		logRecoverableError(request, error);
		fatalError(request, error);
	} finally {
		setCurrentResponseState(prevResponseState);
		ReactCurrentDispatcher.current = prevDispatcher;

		{
			ReactCurrentCache.current = prevCacheDispatcher;
		}

		if (prevDispatcher === HooksDispatcher) {
			// This means that we were in a reentrant work loop. This could happen
			// in a renderer that supports synchronous work like renderToString,
			// when it's called from within another renderer.
			// Normally we don't bother switching the contexts to their root/default
			// values when leaving because we'll likely need the same or similar
			// context again. However, when we're inside a synchronous loop like this
			// we'll to restore the context to what it was before returning.
			switchContext(prevContext);
		}

		currentRequest = prevRequest;
	}
}

function flushSubtree(request, destination, segment) {
	segment.parentFlushed = true;

	switch (segment.status) {
		case PENDING: {
			// We're emitting a placeholder for this segment to be filled in later.
			// Therefore we'll need to assign it an ID - to refer to it by.
			const segmentID = (segment.id = request.nextSegmentId++); // When this segment finally completes it won't be embedded in text since it will flush separately

			segment.lastPushedText = false;
			segment.textEmbedded = false;
			return writePlaceholder(destination, request.responseState, segmentID);
		}

		case COMPLETED: {
			segment.status = FLUSHED;
			let r = true;
			const chunks = segment.chunks;
			let chunkIdx = 0;
			const children = segment.children;

			for (let childIdx = 0; childIdx < children.length; childIdx++) {
				const nextChild = children[childIdx]; // Write all the chunks up until the next child.

				for (; chunkIdx < nextChild.index; chunkIdx++) {
					writeChunk(destination, chunks[chunkIdx]);
				}

				r = flushSegment(request, destination, nextChild);
			} // Finally just write all the remaining chunks

			for (; chunkIdx < chunks.length - 1; chunkIdx++) {
				writeChunk(destination, chunks[chunkIdx]);
			}

			if (chunkIdx < chunks.length) {
				r = writeChunkAndReturn(destination, chunks[chunkIdx]);
			}

			return r;
		}

		default: {
			throw new Error(
				'Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.',
			);
		}
	}
}

function flushSegment(request, destination, segment) {
	const boundary = segment.boundary;

	if (boundary === null) {
		// Not a suspense boundary.
		return flushSubtree(request, destination, segment);
	}

	boundary.parentFlushed = true; // This segment is a Suspense boundary. We need to decide whether to
	// emit the content or the fallback now.

	if (boundary.forceClientRender) {
		// Emit a client rendered suspense boundary wrapper.
		// We never queue the inner boundary so we'll never emit its content or partial segments.
		writeStartClientRenderedSuspenseBoundary(
			destination,
			request.responseState,
			boundary.errorDigest,
		); // Flush the fallback.

		flushSubtree(request, destination, segment);
		return writeEndClientRenderedSuspenseBoundary(destination);
	} else if (boundary.pendingTasks > 0) {
		// This boundary is still loading. Emit a pending suspense boundary wrapper.
		// Assign an ID to refer to the future content by.
		boundary.rootSegmentID = request.nextSegmentId++;

		if (boundary.completedSegments.length > 0) {
			// If this is at least partially complete, we can queue it to be partially emitted early.
			request.partialBoundaries.push(boundary);
		} /// This is the first time we should have referenced this ID.

		const id = (boundary.id = assignSuspenseBoundaryID(request.responseState));
		writeStartPendingSuspenseBoundary(destination, request.responseState, id); // Flush the fallback.

		flushSubtree(request, destination, segment);
		return writeEndPendingSuspenseBoundary(destination);
	} else if (boundary.byteSize > request.progressiveChunkSize) {
		// This boundary is large and will be emitted separately so that we can progressively show
		// other content. We add it to the queue during the flush because we have to ensure that
		// the parent flushes first so that there's something to inject it into.
		// We also have to make sure that it's emitted into the queue in a deterministic slot.
		// I.e. we can't insert it here when it completes.
		// Assign an ID to refer to the future content by.
		boundary.rootSegmentID = request.nextSegmentId++;
		request.completedBoundaries.push(boundary); // Emit a pending rendered suspense boundary wrapper.

		writeStartPendingSuspenseBoundary(
			destination,
			request.responseState,
			boundary.id,
		); // Flush the fallback.

		flushSubtree(request, destination, segment);
		return writeEndPendingSuspenseBoundary(destination);
	} else {
		{
			hoistResources(request.resources, boundary.resources);
		} // We can inline this boundary's content as a complete boundary.

		writeStartCompletedSuspenseBoundary(destination);
		const completedSegments = boundary.completedSegments;

		if (completedSegments.length !== 1) {
			throw new Error(
				'A previously unvisited boundary must have exactly one root segment. This is a bug in React.',
			);
		}

		const contentSegment = completedSegments[0];
		flushSegment(request, destination, contentSegment);
		return writeEndCompletedSuspenseBoundary(destination);
	}
}

function flushClientRenderedBoundary(request, destination, boundary) {
	return writeClientRenderBoundaryInstruction(
		destination,
		request.responseState,
		boundary.id,
		boundary.errorDigest,
		boundary.errorMessage,
		boundary.errorComponentStack,
	);
}

function flushSegmentContainer(request, destination, segment) {
	writeStartSegment(
		destination,
		request.responseState,
		segment.formatContext,
		segment.id,
	);
	flushSegment(request, destination, segment);
	return writeEndSegment(destination, segment.formatContext);
}

function flushCompletedBoundary(request, destination, boundary) {
	{
		setCurrentlyRenderingBoundaryResourcesTarget(
			request.resources,
			boundary.resources,
		);
	}

	const completedSegments = boundary.completedSegments;
	let i = 0;

	for (; i < completedSegments.length; i++) {
		const segment = completedSegments[i];
		flushPartiallyCompletedSegment(request, destination, boundary, segment);
	}

	completedSegments.length = 0;

	{
		writeResourcesForBoundary(
			destination,
			boundary.resources,
			request.responseState,
		);
	}

	return writeCompletedBoundaryInstruction(
		destination,
		request.responseState,
		boundary.id,
		boundary.rootSegmentID,
		boundary.resources,
	);
}

function flushPartialBoundary(request, destination, boundary) {
	{
		setCurrentlyRenderingBoundaryResourcesTarget(
			request.resources,
			boundary.resources,
		);
	}

	const completedSegments = boundary.completedSegments;
	let i = 0;

	for (; i < completedSegments.length; i++) {
		const segment = completedSegments[i];

		if (
			!flushPartiallyCompletedSegment(request, destination, boundary, segment)
		) {
			i++;
			completedSegments.splice(0, i); // Only write as much as the buffer wants. Something higher priority
			// might want to write later.

			return false;
		}
	}

	completedSegments.splice(0, i);

	{
		// The way this is structured we only write resources for partial boundaries
		// if there is no backpressure. Later before we complete the boundary we
		// will write resources regardless of backpressure before we emit the
		// completion instruction
		return writeResourcesForBoundary(
			destination,
			boundary.resources,
			request.responseState,
		);
	}
}

function flushPartiallyCompletedSegment(
	request,
	destination,
	boundary,
	segment,
) {
	if (segment.status === FLUSHED) {
		// We've already flushed this inline.
		return true;
	}

	const segmentID = segment.id;

	if (segmentID === -1) {
		// This segment wasn't previously referred to. This happens at the root of
		// a boundary. We make kind of a leap here and assume this is the root.
		const rootSegmentID = (segment.id = boundary.rootSegmentID);

		if (rootSegmentID === -1) {
			throw new Error(
				'A root segment ID must have been assigned by now. This is a bug in React.',
			);
		}

		return flushSegmentContainer(request, destination, segment);
	} else {
		flushSegmentContainer(request, destination, segment);
		return writeCompletedSegmentInstruction(
			destination,
			request.responseState,
			segmentID,
		);
	}
}

function flushCompletedQueues(request, destination) {
	beginWriting();

	try {
		// The structure of this is to go through each queue one by one and write
		// until the sink tells us to stop. When we should stop, we still finish writing
		// that item fully and then yield. At that point we remove the already completed
		// items up until the point we completed them.
		let i;
		const completedRootSegment = request.completedRootSegment;

		if (completedRootSegment !== null) {
			if (request.pendingRootTasks === 0) {
				if (enableFloat) {
					writePreamble(
						destination,
						request.resources,
						request.responseState,
						request.allPendingTasks === 0,
					);
				}

				flushSegment(request, destination, completedRootSegment);
				request.completedRootSegment = null;
				writeCompletedRoot(destination, request.responseState);
			} else {
				// We haven't flushed the root yet so we don't need to check any other branches further down
				return;
			}
		} else if (request.pendingRootTasks > 0) {
			// We have not yet flushed the root segment so we early return
			return;
		}

		if (enableFloat) {
			writeHoistables(destination, request.resources, request.responseState);
		} // We emit client rendering instructions for already emitted boundaries first.
		// This is so that we can signal to the client to start client rendering them as
		// soon as possible.

		const clientRenderedBoundaries = request.clientRenderedBoundaries;

		for (i = 0; i < clientRenderedBoundaries.length; i++) {
			const boundary = clientRenderedBoundaries[i];

			if (!flushClientRenderedBoundary(request, destination, boundary)) {
				request.destination = null;
				i++;
				clientRenderedBoundaries.splice(0, i);
				return;
			}
		}

		clientRenderedBoundaries.splice(0, i); // Next we emit any complete boundaries. It's better to favor boundaries
		// that are completely done since we can actually show them, than it is to emit
		// any individual segments from a partially complete boundary.

		const completedBoundaries = request.completedBoundaries;

		for (i = 0; i < completedBoundaries.length; i++) {
			const boundary = completedBoundaries[i];

			if (!flushCompletedBoundary(request, destination, boundary)) {
				request.destination = null;
				i++;
				completedBoundaries.splice(0, i);
				return;
			}
		}

		completedBoundaries.splice(0, i); // Allow anything written so far to flush to the underlying sink before
		// we continue with lower priorities.

		completeWriting(destination);
		beginWriting(destination); // TODO: Here we'll emit data used by hydration.
		// Next we emit any segments of any boundaries that are partially complete
		// but not deeply complete.

		const partialBoundaries = request.partialBoundaries;

		for (i = 0; i < partialBoundaries.length; i++) {
			const boundary = partialBoundaries[i];

			if (!flushPartialBoundary(request, destination, boundary)) {
				request.destination = null;
				i++;
				partialBoundaries.splice(0, i);
				return;
			}
		}

		partialBoundaries.splice(0, i); // Next we check the completed boundaries again. This may have had
		// boundaries added to it in case they were too larged to be inlined.
		// New ones might be added in this loop.

		const largeBoundaries = request.completedBoundaries;

		for (i = 0; i < largeBoundaries.length; i++) {
			const boundary = largeBoundaries[i];

			if (!flushCompletedBoundary(request, destination, boundary)) {
				request.destination = null;
				i++;
				largeBoundaries.splice(0, i);
				return;
			}
		}

		largeBoundaries.splice(0, i);
	} finally {
		if (
			request.allPendingTasks === 0 &&
			request.pingedTasks.length === 0 &&
			request.clientRenderedBoundaries.length === 0 &&
			request.completedBoundaries.length === 0 // We don't need to check any partially completed segments because
			// either they have pending task or they're complete.
		) {
			request.flushScheduled = false;

			{
				writePostamble(destination, request.responseState);
			}

			completeWriting(destination);

			close(destination);
		} else {
			completeWriting(destination);
		}
	}
}

function startWork(request) {
	request.flushScheduled = request.destination !== null;

	if (supportsRequestStorage) {
		scheduleWork(() => requestStorage.run(request, performWork, request));
	} else {
		scheduleWork(() => performWork(request));
	}
}

function enqueueFlush(request) {
	if (
		request.flushScheduled === false && // If there are pinged tasks we are going to flush anyway after work completes
		request.pingedTasks.length === 0 && // If there is no destination there is nothing we can flush to. A flush will
		// happen when we start flowing again
		request.destination !== null
	) {
		const destination = request.destination;
		request.flushScheduled = true;
		scheduleWork(() => flushCompletedQueues(request, destination));
	}
}

function startFlowing(request, destination) {
	if (request.status === CLOSING) {
		request.status = CLOSED;
		closeWithError(destination, request.fatalError);
		return;
	}

	if (request.status === CLOSED) {
		return;
	}

	if (request.destination !== null) {
		// We're already flowing.
		return;
	}

	request.destination = destination;

	try {
		flushCompletedQueues(request, destination);
	} catch (error) {
		logRecoverableError(request, error);
		fatalError(request, error);
	}
} // This is called to early terminate a request. It puts all pending boundaries in client rendered state.

function abort(request, reason) {
	try {
		const abortableTasks = request.abortableTasks;

		if (abortableTasks.size > 0) {
			const error =
				reason === undefined
					? new Error('The render was aborted by the server without a reason.')
					: reason;
			abortableTasks.forEach((task) => abortTask(task, request, error));
			abortableTasks.clear();
		}

		if (request.destination !== null) {
			flushCompletedQueues(request, request.destination);
		}
	} catch (error) {
		logRecoverableError(request, error);
		fatalError(request, error);
	}
}
function flushResources(request) {
	enqueueFlush(request);
}
function getResources(request) {
	return request.resources;
}

function renderToReadableStream(children, options) {
	return new Promise((resolve, reject) => {
		let onFatalError;
		let onAllReady;
		const allReady = new Promise((res, rej) => {
			onAllReady = res;
			onFatalError = rej;
		});

		function onShellReady() {
			const stream = new ReadableStream(
				{
					type: 'bytes',
					pull: (controller) => {
						startFlowing(request, controller);
					},
					cancel: (reason) => {
						abort(request);
					},
				}, // $FlowFixMe[prop-missing] size() methods are not allowed on byte streams.
				{
					highWaterMark: 0,
				},
			); // TODO: Move to sub-classing ReadableStream.

			stream.allReady = allReady;
			resolve(stream);
		}

		function onShellError(error) {
			// If the shell errors the caller of `renderToReadableStream` won't have access to `allReady`.
			// However, `allReady` will be rejected by `onFatalError` as well.
			// So we need to catch the duplicate, uncatchable fatal error in `allReady` to prevent a `UnhandledPromiseRejection`.
			allReady.catch(() => {});
			reject(error);
		}

		const resources = createResources();
		const request = createRequest(
			children,
			resources,
			createResponseState(
				resources,
				options ? options.identifierPrefix : undefined,
				options ? options.nonce : undefined,
				options ? options.bootstrapScriptContent : undefined,
				options ? options.bootstrapScripts : undefined,
				options ? options.bootstrapModules : undefined,
				options ? options.unstable_externalRuntimeSrc : undefined,
			),
			createRootFormatContext(options ? options.namespaceURI : undefined),
			options ? options.progressiveChunkSize : undefined,
			options ? options.onError : undefined,
			onAllReady,
			onShellReady,
			onShellError,
			onFatalError,
		);

		if (options && options.signal) {
			const signal = options.signal;

			if (signal.aborted) {
				abort(request, signal.reason);
			} else {
				const listener = () => {
					abort(request, signal.reason);
					signal.removeEventListener('abort', listener);
				};

				signal.addEventListener('abort', listener);
			}
		}

		startWork(request);
	});
}

export { renderToReadableStream, ReactVersion as version };
